<div class="blogArticleTitle">
 Preen Release 1A: a Kestrel-2 Monitor
</div>
<div class="blogArticleTimestampAuthor">
 <div class="blogArticleAuthor">Samuel A. Falvo II<br>kc5tja -at- arrl.net</div>
 <div class="blogArticleTimestamp">2011 Aug 27 17:34 PDT</div>
</div>
<div class="blogArticleLead">
 <p>
  Bringing up a new computer from scratch poses a chicken-and-egg problem.  When the system software under development unexpectedly fails, no extant means exists to determine hardware or software culpability.  A reference program written to run under both an emulator and physical hardware can help isolate causes of failure.  Software which fails on physical hardware but not in an emulated environment justifies further investment in debugging the hardware.
 </p>
 <p>
  Ideally, the reference program should exercise, at a minimum, all peripherals required to support an interactive user experience.  A personal computer without a user interface serves no useful purpose.  A simple monitor program provides a means to exercise a video display output, keyboard input, and some more esoteric properties of the host CPU.  Further, a monitor may provide a useful debugging aid for diagnosing problems when higher-level software or hardware components fail.
 </p>
</div>
<div class="blogArticleBody">

<h1>10  Binary Image Generation</h1>
@ All target compiler sources run under an ANS Forth environment, such as SwiftForth.  We start Forth using something like <q>sf [[preen.f]]</q>, and rely on the implementation of [[preen.f]] to do the right thing.  Since we're assembling code for the target processor, we need to load the assembler into the host's dictionary.</p>

<<Load target development>>=
include asm.f
@

When first loaded, the assembler will exist in an inconsistent state.  We need to reset the assembler's internal state.</p>

<<Load target development>>=
0symtab
@

The J1 processor begins its execution at address zero in its memory map.  Since the assembler doesn't yet know what code we're going to place further on in memory, we're going to compile a forward jump.  The Forth word [[DEFER]] works by writing an uninitialized vector, making it ideal for this purpose.  Later, when we're done assembling, we can patch up this vector with the proper entry point address.</p>

<<Origin directive>>=
0 org
<<Reset vector>>=
defer _main
@ %def _main
<<Patch reset vector>>=
: b breakpoint  recurse ;
' b is _main
@

Once everything's been assembled, we create the ROM file on the host computer, and terminate the Forth session.</p>

<<Emit binary file>>=
host  there . s" bytes compiled" type cr  romfile  bye
@

All other sections refer to target-specific code, so let's make sure we configure the Forth environment to produce software in the target.</p>

<<Origin directive>>=
target
@

In summary, the top-level layout of the program follows:</p>

<<preen.f>>=
<<Load target development>>
<<Origin directive>>
<<Reset vector>>
<<Preen Code>>
<<Patch reset vector>>
<<Emit binary file>>
@ </p>

<h1>15  Executive Summary of Preen Code</h1>

@ The main Preen software consists of several major functional parts.  An executive summary of each section appears below.  More detailed explanations exist for each chunk of code in later sections of this document.</p>

@ Before we can compile anything else in the software, we need a set of baseline Forth primitives.</p>

<<Preen Code>>=
<<Primitives>>
@

While the screen editor outputs characters to a character matrix, something still needs to render that character matrix to the screen.</p>

<<Preen Code>>=
<<Text Display Facility>>
@

The screen editor consists of two main parts: those things handling user input, and those things handling output to a character matrix.  Relating to output, the screen editor includes cursor management,</p>

<<Preen Code>>=
<<Screen Editor State>>
<<Screen Editor Cursor Movement>>
@

cursor blinking support,</p>

<<Preen Code>>=
<<Screen Editor Blink Address>>
<<Screen Editor Cursor Blink>>
<<Turning Off the Cursor>>
<<Blink Event Handler>>
@

knowledge of when to redraw the screen into the Kestrel's bitmapped frame buffer,</p>

<<Preen Code>>=
<<Character Matrix Commit Flag>>
<<Screen Refresh Event Handler>>
<<Character Matrix Buffer>>
@

and generic text output routines such as the familiar Forth [[EMIT]], [[TYPE]], et. al.</p>

<<Preen Code>>=
<<Clearing the screen>>
<<Placing a Character>>
<<Placing a String>>
<<Carriage Return>>
@

Preen wouldn't qualify as a proper monitor if it couldn't let users execute the programs that he keys in.</p>

<<Preen Code>>=
<<System software state>>
<<[[GO]] Command>>
@

Once the system knows how to draw a character matrix to the screen, and how to render text into the character matrix, Preen needs to provide functionality to let the user see the contents of memory.</p>

<<Preen Code>>=
<<Definition of [[SPACE]]>>
<<Definition of [[.B]]>>
<<Definition of [[W]]>>
<<Definition of [[WORDS]]>>
<<Definition of [[CHARS]]>>
<<Definition of [[DUMP]]>>
<<Dumping Data Stack>>
<<Dumping Return Stack>>
<<Dumping Arbitrary Memory>>
<<Memory Dump>>
@

When a user issues a command to Preen, it must interpret it.  We depend on typical Forth lexing rules to parse out command tokens and parameters.</p>

<<Preen Code>>=
<<Interpreter State>>
<<Matrix Character Fetch>>
<<End-of-line check>>
<<Whitespace check>>
<<Forth Word Lexing>>
@

Most commands take parameters in the form of hexadecimal numbers.</p>

<<Preen Code>>=
<<Numeric Accumulator>>
<<Accumulate a single hex digit>>
<<Convert a string into a number>>
<<Grab a numeric parameter>>
@

Above, we saw that Preen let you execute programs that the user can key in.  This requires the ability for a user to change memory locations interactively.</p>

<<Preen Code>>=
<<Store Data>>
<<Memory Store Commands>>
<<Memory Pointer Change Command>>
@

Preen references commands via look-up tables.</p>

<<Preen Code>>=
<<Command Procedure Table>>
<<Command Name Table>>
<<Command Search Step>>
<<Command Search>>
@

Syntactically speaking, Preen's command interpreter works very much like the Windows or Unix command interpreter.</p>

<<Preen Code>>=
<<Display Routine Address>>
<<Map Command Name to Executable Address>>
<<Command Length Check>>
<<Command Dispatch>>
<<Command Interpreter>>
@

The screen editor consists of both input and output halves.  Handling keyboard input requires checking detected key codes for commands like <q>move cursor up</q>, pressing [[ENTER]] to submit a command, or simply overwriting a character with a hexadecimal digit.</p>

<<Preen Code>>=
<<Keycode to Rawcode Lookup Table>>
<<Rawcode to ASCII Lookup Table>>
<<Convert keycode to ASCII>>
<<Valid Hexadecimal Digit Handler>>
<<Rawcode Table Scanner>>
<<Cursor Movement Dispatch>>
<<ENTER dispatch>>
<<Keyboard dispatcher>>
@

The screen editor consumes received keyboard events.  However, it's aware only of <q>cooked</q> keyboard events.  We therefore need a PS/2 keyboard driver to interact with the low-level hardware and refine the raw events into something the screen editor can understand.</p>

<<Preen Code>>=
<<PS/2 State>>
<<PS/2 Flag Intercepts>>
<<PS/2 Keycode Filter>>
<<PS/2 Keyboard Driver>>
@

The Preen debugger works by painting the screen with its desired user interface, then invokes the screen editor to serve as the user's primary user interface.</p>

<<Preen Code>>=
<<User Interface Main Loop>>
<<User Interface Entrypoint>>
<<Breakpoint handler>>
@

<h1>20  Breakpoints</h1>
@ The J1 processor as used in the Kestrel-2 lacks interrupts; therefore, the processor cannot reasonably respond to such things as illegal memory accesses or malformed instructions.  Control transfers to the monitor, like all other software on the J1 processor, through explicit control flow instructions.  In this case, applications explicitly invoke a <i>breakpoint</i>.</p>

<h2>20.1  Saving Processor State</h2>

@ A breakpoint behaves like a software-defined interrupt.  The application containing a breakpoint instruction <i>trusts</i> the processor state will remain unaltered before and afterwards.  Of course, the user has the option of altering the state of the running program.  In order to display the machine state to the user, we must preserve it in memory somewhere, so we'll need some storage space.  We place our state explicitly instead of relying on [[CREATE]] to minimize data stack usage.  There's a low probability that a program will ever reach the extremities of program space, so we place our buffers there out of convenience.</p>

<<System software state>>=
: dstack        $3F00 ;
: rstack        dstack 64 + ;
@ %def dstack rstack

You'll notice that no space exists for the program counter.  Since we invoke the breakpoint handler via a [[CALL]] instruction, it already exists at the top of the return stack.  <i>Note that this implies that only 31 return stack elements are preserved by the breakpoint handler.</i>  Therefore, Preen will likely cause any program which depends on the availability of all 32 return stack registers to crash.</p>

@ The J1 provides the programmer with <i>33</i> data stack registers.  These include [[T]], the top of the stack which feeds the J1's first ALU input, and 32 other stack registers.  However, in the state above, we reserve only 32 slots.  Since the J1 lacks an instruction to store its state in a memory location, we need to use [[!]] to store to memory the state of the data stack.  Pushing the address that [[!]] will store to necessarily causes the 33rd stack cell to disappear, <i>thus leaving only 32 of the 33 data stack items available for inspection.</i>  Preen will likely cause any program which depends on the availability of all 33 data stack registers to crash.</p>

@ When the breakpoint hits, Preen must assume the program uses all data and return stack items.  Therefore, the breakpoint handler must free up enough stack space to function.  At first, I tried freeing up a handful of stack items to allow for procedure calls, then rely on colon definitions to write out the rest of the stack items.  This clever approach involved the use of the [[SWAP]] instruction which, alas, suffers from an as-yet-unfixed bug in the Kestrel-2 emulator, which causes stack corruption whenever the data stack pointer equals 0.  As a work-around, we just bite the bullet and dump <i>all</i> stack items manually in their associated memory locations.  Not only does this work-around reliably function, it also benefits from being far simpler to understand.</p>
<<Breakpoint handler>>=
: breakpoint
  <<Save data stack items>>
  <<Save return stack items>>
@ %def breakpoint
<<Save data stack items>>=
$3F00 !  $3F02 !  $3F04 !  $3F06 !
$3F08 !  $3F0A !  $3F0C !  $3F0E !
$3F10 !  $3F12 !  $3F14 !  $3F16 !
$3F18 !  $3F1A !  $3F1C !  $3F1E !
$3F20 !  $3F22 !  $3F24 !  $3F26 !
$3F28 !  $3F2A !  $3F2C !  $3F2E !
$3F30 !  $3F32 !  $3F34 !  $3F36 !
$3F38 !  $3F3A !  $3F3C !  $3F3E !
@
<<Save return stack items>>=
r> $3F40 !  r> $3F42 !  r> $3F44 !  r> $3F46 !
r> $3F48 !  r> $3F4A !  r> $3F4C !  r> $3F4E !
r> $3F50 !  r> $3F52 !  r> $3F54 !  r> $3F56 !
r> $3F58 !  r> $3F5A !  r> $3F5C !  r> $3F5E !
r> $3F60 !  r> $3F62 !  r> $3F64 !  r> $3F66 !
r> $3F68 !  r> $3F6A !  r> $3F6C !  r> $3F6E !
r> $3F70 !  r> $3F72 !  r> $3F74 !  r> $3F76 !
r> $3F78 !  r> $3F7A !  r> $3F7C !  r> $3F7E !
@

Once both the data and return stacks have been committed to memory, the entire state of the interrupted program avails itself for inspection.  Recall that the interrupted program's instruction pointer resides in the cell at [[rstack]]+0.  This leaves [[breakpoint]] with only one last task to perform: kick off the monitor's user interface.</p>

<<Breakpoint handler>>=
scrn TdfChrMtx !  display ui ;
@

Note that [[ui]] never returns.</p>

<h2>20.2  Restoring Processor State</h2>

<p>Although one speaks frequently of <q>returning</q> from a breakpoint, as one would return from an interrupt, we find actual practice more closely resembles a computed jump.  I rely on this feature to implement a Forth word that lets us <q>return</q> to the monitored program.  It allows us to execute arbitrary programs in memory from the debugger interface.</p>

<<[[GO]] Command>>=
: GO
  <<Restore Return Stack>>
  <<Restore Data Stack>> ;
@ %def GO

As you might expect, restoring the data and return stacks are pretty straight-forward, albeit tiring to type, fragments of code.  Observe that we restore the data stack <i>after</i> the return stack, to avoid data stack pollution that would occur otherwise.</p>

<<Restore Return Stack>>=
$3F7E @ >r $3F7C @ >r $3F7A @ >r $3F78 @ >r
$3F76 @ >r $3F74 @ >r $3F72 @ >r $3F70 @ >r
$3F6E @ >r $3F6C @ >r $3F6A @ >r $3F68 @ >r
$3F66 @ >r $3F64 @ >r $3F62 @ >r $3F60 @ >r
$3F5E @ >r $3F5C @ >r $3F5A @ >r $3F58 @ >r
$3F56 @ >r $3F54 @ >r $3F52 @ >r $3F50 @ >r
$3F4E @ >r $3F4C @ >r $3F4A @ >r $3F48 @ >r
$3F46 @ >r $3F44 @ >r $3F42 @ >r $3F40 @ >r
@

<<Restore Data Stack>>=
$3F3E @    $3F3C @    $3F3A @    $3F38 @
$3F36 @    $3F34 @    $3F32 @    $3F30 @
$3F2E @    $3F2C @    $3F2A @    $3F28 @
$3F26 @    $3F24 @    $3F22 @    $3F20 @
$3F1E @    $3F1C @    $3F1A @    $3F18 @
$3F16 @    $3F14 @    $3F12 @    $3F10 @
$3F0E @    $3F0C @    $3F0A @    $3F08 @
$3F06 @    $3F04 @    $3F02 @    $3F00 @
@ </p>

<h1>25  Dumping Memory</h1>

<p>All monitors, by their very nature, provide visibility into arbitrary regions of memory.  Preen provides a display with three different regions on the screen.</p>

<<Three memory dump regions>>=
dstk rstk mem
@ </p>

The three regions are framed on the display by the monitor's identification on top, and the [[GO]] command on the bottom.

<<Memory Dump>>=
: banner        S" Kestrel Preen 1A" type cr cr ;
: display
  page banner
  <<Three memory dump regions>>
  S" GO" type cr ;
@ %def display

We re-use the same memory dump code for all three types of regions.  We simply hard-wire the starting address for the data and return stack regions, while leaving the [[mem]] region freely relocatable by the user.</p>

<<Dumping Data Stack>>=
: d00           S" D+ 00  " type $3F00 dump ;
: d10           S" D+ 10  " type $3F10 dump ;
: d20           S" D+ 20  " type $3F20 dump ;
: d30           S" D+ 30  " type $3F30 dump ;
: dstk          d00 d10 d20 d30 cr ;
@ %def dstk

<<Dumping Return Stack>>=
: r00           S" R+ 00  " type $3F40 dump ;
: r10           S" R+ 10  " type $3F50 dump ;
: r20           S" R+ 20  " type $3F60 dump ;
: r30           S" R+ 30  " type $3F70 dump ;
: rstk          r00 r10 r20 r30 cr ;
@ %def rstk

<<System software state>>=
variable memptr
@ %def memptr

<<Dumping Arbitrary Memory>>=
: m             S" M+ " type dup .b space space dup memptr @ + dump 16 + ;
: mem           S" M= " type memptr @ .w cr 0 m m m m m m m m drop cr ;
@ %def mem

Like most monitors, Preen offers two visualizations for the same data: hexadecimal values and their ASCII equivalents, separated by an em-dash.

<<Definition of [[DUMP]]>>=
: dump          words S" -- " type -16 + chars cr drop ;
@ %def dump

Each dump consists of sixteen bytes, arranged as eight words since the J1 processor addresses memory using words, not bytes:</p>

<<Definition of [[WORDS]]>>=
: words         w w w w w w w w ;
@ %def words

We print each word's value by printing two bytes, most significant first, then advancing the fetch pointer by two so that the next time we print, we fetch the next word as expected.</p>

<<Definition of [[SPACE]]>>=
: space         $20 emit ;
@ %def space

<<Definition of [[W]]>>=
: .w            dup 8 rshift .b .b space ;
: w             dup @ .w 2 + ;
@ %def w

Similarly, we dump each byte's value by breaking it into nybbles, most significant first.  Then, we rely on a character look-up table to translate each nybble's value into an ASCII code suitable for display.</p>

<<Definition of [[.B]]>>=
: .n            $F and S" 0123456789ABCDEF" drop + c@ emit ;
: .b            dup 4 rshift .n .n ;
@ %def .b

Upon completion of the eight word dump, the address on the stack will point 16 bytes after of our intended region.  For this reason, [[dump]] subtracts 16 before producing the ASCII visualization of the memory buffer.</p>

@ Many computers rely on monitors or debuggers which emits character data through a <q>cooked</q> character output routine.  This means that the system firmware or host operating system interprets some characters as control codes, instructing the computer to do such things as change character sets, move the cursor, etc.  Often, these same computers lacks a one-to-one mapping between ASCII code and the corresponding glyph.  For example, a Commodore 64 maps ASCII code 65 (capital A) to screen code 1.  This complicates the design of any monitor, because supporting awareness of this <q>convenience</q> requires additional software to avoid distorting the display unintentionally.  For this reason, most monitors will filter the ASCII view of raw data, substituting such unprintable characters with a simple period.</p>

@ Preen, however, avoids all of this mess through two features: (1) all printable characters have glyph indices matching their ASCII codes, and (2) no special characters exist.  Rather, Preen relies on a programming interface to perform such duties as moving the cursor or clearing the screen.  Combined, this simplifies printing a 16-character ASCII view of a raw data buffer significantly.</p>

<<Definition of [[CHARS]]>>=
: c             dup c@ emit 1 + ;
: chars         c c c c c c c c  c c c c c c c c ;
@ %def chars

<h1>30  Screen Editing Facility</h1>

@ Most computer operating systems implement a <q>glass teletype</q> abstraction for their user interface.  In this interface, the computer prints characters to a video display, and the user responds, sequentially, line after line, character after character, as though they still worked with paper print-outs.  No means generally exists of exploiting the two-dimensional surface of the display.  This creates a plurality of complications that both the user and the systems software engineer need to consider.</p>

<ul>
 <li>
  From a usability perspective, the user cannot use the arrow keys to move the cursor to a wrong command and fix it, a rather obvious feature when you think about it.  Many operating systems provide <q>command-line history</q> as a useful, albeit sorely limited, substitute.
 </li>
 <li>
  From an application developer's persepctive, the application developer needs to go out of his or her way to incorporate history functionality.  While typically encapsulated in support libraries to make doing so easier, the programmer still must consciously think to include the library and hope for the best compatibility if an update to the library comes out afterwards.  On the author's Linux installation, for example, three versions of GNU ReadLine library exists, all of which are used.
 </li>
 <li>
  From a systems software engineering perspective, the teletype interface adds <i>immense</i> complexity to the user interface.  A typical Unix console interface, for example, performs activities normally expected of <i>serial-line</i> interfaces (e.g., RS-232 or X.25), despite no such physical resources existing in the path between the application and the video frame buffer on modern systems, including but not limited to such matters as implementing line-delay after receiving an end-of-line indication, translation of carriage returns or newlines into each other, or worse, into both a carriage return/line feed pair.  Character set munging, retaining their <q>7-bit clean</q> I/O model from the 70s, proves how retarded such abstractions remain in today's world of 8-bit-clean video devices.  It gets worse though &mdash; inline embedding of what should be out-of-band controls require stateful interpretation, but which command-set do you use?  In the 60s and 70s, when competition in the dumb terminal market proved fierce and vibrant, such sophisticated libraries as [[termcap]] and [[terminfo]] proved useful.  Today, they represent nothing but baggage, as virtually <i>every</i> device claiming it's a terminal emulator these days understands the DEC VT-100 command set.  These abstractions help only the simplest possible software in rendering textual output portably; for all other cases, even those <i>simple</i> applications seeking to capture the difference between the [[ALT-A]] key from just a normal [[A]] key, all require awareness of the limitations and complexities imposed by the host environment.  Worse still, nearly every environment further places the burden of restoring the I/O channel to its previously complexity levels prior to exiting.  For example, in Linux at least, a curses application which unexpectedly segfaults often leaves the user's terminal in an unknown, often completely unusable, state which [[reset]] may not always recover from.
 </li>
</ul>

@ A screen editor treats the addressible display as an interactive, editable document.  We achieve command-line history for free, for the user may re-issue any command still visible on the screen.  Application writers needn't concern themselves with including support for command-line history explicitly.</p>

@ Broadly, two kinds exist &mdash; array editors and matrix editors.  An array editor most closely corresponds to a traditional text editor, such as Notepad, Emacs, or Vim.  These editors tend to rely on data structures such as gap buffers or ropes to manage the textual content, since no one-to-one correspondence exists between text buffer and the concrete representation thereof.  Array editors work best with variable-geometry displays, such as those found in graphical user interfaces.  Matrix editors, however, rely on a fixed geometry and fixed-width fonts to simplify their implementation.  In most other respects, the two varieties of editor interfaces match each other in features and usability.</p>

@ Preen uses a (too?) simple matrix editor with a fixed 80&times;25 geometry.  The combination of this geometry and an isomorphism between ASCII code and font glyph allows Preen to re-use the same character matrix with the Text Display Facility for display refresh purposes.  Preen's screen editor only supports the functionality considered essential for Preen's operation: entering of hexadecimal numbers, and selection of the [[GO]] command.</p>

@ The screen editor consists of two major components: output and input.  This chapter deals with the <q>high level</q> screen output functionality, while the section on the text display facility discusses the low-level output to the framebuffer.  We discuss input functionality in the subsequent keyboard sections.</p>

<h2>30.1  Character Matrix</h2>

@ The Kestrel-2 supports a simplistic display interface, consisting of a 16KB buffer starting at [[$8000]] and offering a 640&times;200 video resolution.  With an 8&times;8 pixel character font, this gives us an 80&times;25 character matrix, assuming we keep characters aligned to eight pixel boundaries.  Correspondingly, the screen editor works on a buffer 80&times;25 = 2000 bytes in size.</p>

<<Character Matrix Buffer>>=
create scrn
    2000 allot
@ %def scrn

For the purposes of receiving input from the user, Preen treats the character matrix as a 25-element array of 80-character line records.  Since none of Preen's inputs can possibly span multiple lines, the screen editor doesn't support so-called <q>logical lines</q>, such as the screen editors found in Commodore and Atari 8-bit products support.</p>

<h2>30.2  Cursor Movement</h2>

@ Preen lets the user and applications locate the cursor anywhere on the display.  A pair of variables keeps track of the cursor at all times.</p>

<<Screen Editor State>>=
variable x
variable y
@ %def x y

Software can relocate the cursor at any time, but we take care to ensure the new location remains on the screen.  Otherwise, we risk memory corruption when we [[emit]] or [[type]] next.</p>

<<Screen Editor Cursor Movement>>=
: confine   x @ 0 max 79 min x !   y @ 0 max 24 min y ! ;
: at-xy     y ! x ! confine ;
@ %def at-xy confine

Pressing one of the four cursor keys will cause the cursor to move about the screen in the desired direction.  We implement this by updating the [[x]] and [[y]] variables, making sure to confine them to the appropriate bounding rectangle.  Make sure you turn the cursor off ([[coff]], defined later) before altering the cursor location, or you risk cosmetic problems.</p>

<<Screen Editor Cursor Movement>>=
: up        -1 y +! confine ;
: down       1 y +! confine ;
: left      -1 x +! confine ;
: right      1 x +! confine ;
@ %def up down left right

The keyboard interface software invokes [[up]], [[down]], [[left]], and [[right]] in response to handling arrow key presses.  We'll discuss this logic in the appropriate section.</p>

<h2>30.3  Character Output: [[type]], [[emit]], and [[page]]</h2>

@ Once the cursor has been placed, text output occurs by placing bytes into the character matrix and advancing the cursor to the right.  [[emit]] places individual characters:</p>

<<Placing a Character>>=
: plot          TdfChrMtx @ y @ 80* x @ + + c! ;
: emit          plot right -1 commit? !  ;
@ %def emit

The [[type]] word supports printing of entire strings, provided they do not span multiple lines.</p>

<<Placing a String>>=
: type          dup if over c@ emit -1 + swap 1 + swap recurse exit then 2drop ;
@ %def type

If a string does span multiple lines, you'll find the lack of wrap-around logic will truncate the string to the current line only.  You'll want to split the line up into smaller segments, and print each one independently, using [[cr]] to perform a carriage return.</p>

<<Carriage Return>>=
: cr            0 x ! down ;
@ %def cr

Note that the lack of vertical screen scroll support further confines output to a single display's worth at a time.  Since the monitor's output never spans more than 23 lines, I left vertical scroll support out.  One work-around involves the use of a pager, which renders a single page of text at a time, clears the screen with [[page]], then renders the next page, and so on.  (This actually works quite well for Kestrel-2-generated slide presentations.)</p>

<<Clearing the screen>>=
: clr           dup if swap 32 over c! 1 + swap -1 + recurse exit then 2drop ;
: page          TdfChrMtx @ 2000 clr  0 x !  0 y ! ;
@ %def page

<h2>30.4  User Interface Loop</h2>

@ When Preen desires user input, it invokes [[ui]] to present the screen editor user interface to the user.  It first establishes reasonable defaults for its operating state, then drops into the main loop proper.</p>

<<User Interface Entrypoint>>=
: ui            0 s !  0 blst !  ui... coff ;
@ %def ui

The user interface main loop repeatedly polls for input events, and handles them as it finds each kind of event.</p>

<<User Interface Main Loop>>=
: ui...         ?commit blinker keyboard recurse ;
@ %def ui...

@ You might have noticed that we're setting a flag called [[commit?]] in the definition for [[emit]].  This flag, when set, informs the application's user interface loop that at least one screen character changed since the last refresh.</p>

<<Character Matrix Commit Flag>>=
variable commit?
@ %def commit?

Refreshing the display involves touching over 16 000 bytes using both [[c@]] and [[c!]], both very slow operations on the current generation of J1 processor technology.  Thus, [[commit?]] allows us to defer a full-screen refresh until we know all text output has completed.</p>

<<Screen Refresh Event Handler>>=
: ?commit       commit? @ if coff commit blink 0 commit? ! then ;
@ %def ?commit

Next, we handle the blink animation of the cursor.  Each time through the [[ui...]] loop, we increment the blink counter [[blct]].  When it reaches an empirically determined threshold, we toggle the state of the cursor on the screen.</p>

<p>I have discovered through my own experiences that a text cursor should blink fairly rapidly, and should cover the entire character cell.  Slowly blinking cursors don't seem to have the desired effect of telling me at a glance where my insertion point is.  Static solid block cursors, including those which rely on reverse video, too often blur into the background for me, leaving me effectively blind to them.  The human eye evolved to detect motion in both the foreground and the periphery, so it makes sense to exploit that feature of human vision. I chose to blink the cursor at a rate of four times every second.  The constant, [[49152]], happens to match this rate given the current editor UI loop overhead and processor speed.  My eye appreciates this blink rate the best.</p>

<<Blink Event Handler>>=
variable blct
: blinker       1 blct @ + dup 49152 xor if blct ! exit then drop blink 0 blct ! ;
@ %def blinker

We implement the text cursor by reversing the video of a given character glyph in the bitmap. In addition, we'll toggle a flag in memory, so we know whether we've reversed the video or not. This will come in handy for when we want to "turn off" the cursor.</p>

<<Screen Editor Cursor Blink>>=
variable blst
: b             dup dup c@ invert swap c! 80 + ;
: blink         address b b b b b b b b drop  blst @ -1 xor blst ! ;
@ %def blink

@ We calculate the bitmap address of the glyph under the cursor by considering the cursor's current location.</p>

<<Screen Editor Blink Address>>=
: address       y @ 640* x @ + $8000 + ;
@ %def address

We know that [[blink]] inverts itself, so turning off a cursor involves calling [[blink]] if, and only if, we know the video underneath the cursor has already been inverted.

<<Turning Off the Cursor>>=
: coff          blst @ if blink then ;
@ %def coff

The [[keyboard]] definition encapsulates both the PS/2 keyboard driver and the screen editor's event handler.  We'll discuss the keyboard handling logic in its own section below.

<h1>40  Text Display Facility</h2>

<p>The Kestrel-2 lacks a hardware character matrix display mode; instead, the video circuitry fetches bytes from memory starting at address [[$8000]] and displays them as a raw bitmap.  We cannot simply poke bytes into memory and expect fully-formed characters to appear on the screen.  Preen provides a facility to emulate character matrix displays in software.  This results in a simpler hardware implementation and graphics when you need it, while incurring only modest software costs.</p>

<<Text Display Facility>>=
<<TDF global state>>

@ </p>
<h2>40.1  Character Font</h2>

<p>The 640&times;200 display resolution requires (640&div;16)&times;200=8 000 words of memory.  Using an 8&times;8 pixel font, that allows us to pack 80 columns by 25 rows of text on the screen.  The Kestrel-2 expects a single word of memory to hold two characters (or, put another way, one character consumes eight bits of storage), so (80&div;2)&times;25=1 000 words hold a complete character matrix.  This lets us represent up to 256 characters in a single character matrix.</p>

<p>Displaying text requires we provide a number of small, 8&times;8 images, each representing some character on the screen.  I call each image a <i>glyph</i>.  The <i>font</i> contains the set of glyphs corresponding to each character.  Preen expects the font to exist as a 2 048&times;8 bitmap in memory, for 256 possible characters times 8 pixels per glyph row comes out to 2 048 total pixels.  Thus, the first 128 words (256 bytes) constitutes row 0 pixels for all 256 characters, the next 128 words row 1 pixels, and so on.  Arranging the font data this way allows a developer to use an image editing tool of his or her choice to create a font, then extract the raw bitmap data for direct use with the Kestrel-2.</p>

<p>The Kestrel-2 firmware references the font data via an ancillary Forth source file.
<<Text Display Facility>>=
<<TDF System Font>>

<<TDF System Font>>=
create font
include font.inc
@

<h2>40.2  Committing a Character Matrix</h2>

<p>In a perfect world, we would somehow convince the hardware to monitor some region of memory which we call the <i>character matrix</i> for updates.  Whenever we update memory in the matrix, the hardware would somehow recognize this event, and adjust the display accordingly.  Two ways exist to approach the problem&mdash;you could either poll memory at periodic intervals, such as how video display systems like VGA, Atari ANTIC, or the Commodore VIC-II chip behaves.  Alternatively, you can maintain what's called a <q>write queue</q> to trap writes into the character matrix, where a processor on the other end of the queue discovers these writes and acts accordingly, such as how Firewire peripherals operate.  As you can imagine, maintaining a write queue doesn't really solve the problem, but rather defers the problem of video refresh to an external peripheral.  The polling technique works by accessing memory <i>twice</i>; once to read the character, and once to grab the font data corresponding to that character, at a rate sufficiently fast to keep up with the monitor's scanning electron beam.  I could have implemented this in the Kestrel-2's video circuitry, but since it roughly doubled the complexity of the hardware involved, I decided to just keep things as simple as possible, and stick with a pure bitmapped display interface.</p>

<p>Updating the bitmapped display takes eight times the effort of updating a simple character matrix.  Therefore, we want to minimize how often we actually push updates to the bitmapped display.  It's better to compute what we want the finished display to look like first, in the form of the character matrix, <i>then</i> perform a bulk update of the whole screen.  When we talk of <q>committing</q> a character matrix, we're talking about that final act of bulk-updating the bitmapped display.  The term comes from the field of transactions, where updates to a resource occurs when the transaction completes.</p>

<p>I implement a relatively slow algorithm below, but one which works well.  It takes the overall form:</p>
<<Text Display Facility>>=
<<TDF address computation logic>>
<<TDF commit glyph logic>>
<<TDF commit row logic>>
<<TDF commit screen-wide logic>>
<<TDF character matrix commit logic>>

@ We commit the display character by character, one glyph at a time, starting in the upper-lefthand corner of the display.  We know we need to update 25 rows of text.</p>

<<TDF character matrix commit logic>>=
: commit    0 x !  0 y !  25r ;
@ %def commit

We address each character through the [[x]] and [[y]] state variables.  Note that these variables <i>do not</i> refer to any kind of cursor position; they're used only while committing the display, keeping track of which glyph we're painting into the bitmap.  They conform to the invariant that (0&le;<i>x</i>&lt;80)&and;(0&le;<i>y</i>&lt;25) while the screen update continues to proceed.</p>

<<TDF global state>>=
variable x
variable y
@ %def x y

A screen consists of 25 rows, as established above.  If each execution of [[r]] bumps the [[y]] variable by one, then we can clearly see that upon completion of the operation, [[y]] will equal 25.  While the update proceeds, we see that 0&le;<i>y</i>&lt;25, thus satisfying the invariant.</p>

<<TDF commit screen-wide logic>>=
: 8r        r r r r  r r r r ;
: 25r       8r 8r 8r r ;
@ %def 25r

Each row consists of 80 characters apiece.  As each row completes, we make sure to reset our (x,y) coordinates to keep track of where the next row begins.  During the update of a single row, 0&le;<i>x</i>&le;80.  However, because [[r]] resets the [[x]] variable back to zero upon finishing each row, and because we know that 0&le;<i>y</i>&lt;25 while the commit progresses, the global invariants hold.</p>

<<TDF commit row logic>>=
: 10c       c c c c c  c c c c c ;
: 80c       10c 10c 10c 10c  10c 10c 10c 10c ;
: r         80c  0 x ! 1 y @ + y ! ;
@ %def r

We draw each character by cycling through all eight raster lines of its shape, copying data from the font data to the bitmap along the way.  After we're done copying the glyph, we update our (x,y) state to prepare for copying the next character.</p>

<<TDF commit glyph logic>>=
: s         chradr c@ glyph c@ bmadr c!  1 raster @ + raster ! ;
: c         0 raster !  s s s s  s s s s  1 x @ + x ! ;
@ %def c

When updating the bitmap, we need to know which character to draw.  We address a character in the character matrix based on the current (valid) values of the [[x]] and [[y]] variables, according to the following equation: <i>a</i> = <i>character_matrix_base</i> + <i>x</i> + 80<i>y</i>.</p>

<<TDF address computation logic>>=
: chradr    y @ 80* x @ + TdfChrMtx @ + ;
@ %def chradr

<<TDF global state>>=
variable TdfChrMtx
@ %def TdfChrMtx

The TDF user must initialize the [[TdfChrMtx]] variable prior to invoking [[commit]], lest we render garbage on the screen.  Further, make sure the 1 000 cells referenced by [[TdfChrMtx]] never overlaps read-triggered I/O space, as the screen update will fire the I/O triggers.</p>

<p>Next, we need to resolve which row of the glyph's picture to use.  We calculate the glyph's bitmap byte address using the character code (on the data stack) and knowledge of which [[raster]] we're drawing.  Its formula is, <i>a</i> = <i>font_base</i> + <i>c</i> + 256<i>s</i>, where 0&le;<i>c</i>&lt;256 contains the character code, and 0&le;<i>s</i>&lt;8 contains the current raster scanline.

<<TDF address computation logic>>=
: glyph     font + raster @ 256* + ;
@ %def glyph

<<TDF global state>>=
variable raster
@ %def raster

Finally, we just place the glyph image data in the destination bitmap.  We compute the the correct row of pixels in the target bitmap using a formula similar to that used to determine the character matrix byte address, but adjusted to compensate for the bitmapped nature: <i>a</i> = <i>bitmap_base</i> + <i>x</i> + 80<i>s</i> + 640<i>y</i>, where 0&le;<i>s</i>&lt;8 refers to the specific scanline of the glyph.  Remember, we defined the system font height as eight.</p>

<<TDF address computation logic>>=
: bmadr     y @ 640* raster @ 80* + x @ + $8000 + ;
@ %def bmadr

<h2>40.3  Mathematics Primitives</h2>

@ You might have noticed a few multiplications going on, expressed as single words instead of separate calls to [[*]].  The J1, not being a terribly sophisticated processor, lacks hardware multiplication support.  This means that we'd need to implement [[*]], a non-trivial task, if we wanted to perform general purpose multiplication.  As it happens, we always multiply by a constant factor, which allows us to create words which computes the desired results using <i>shifts and additions</i> instead.  This also has the benefit of isolating the Text Display Facility from the rest of the system firmware, useful for debugging purposes.</p>

<<Primitives>>=
: 8*        3 lshift ;
: 16*       4 lshift ;
: 80*       4 lshift dup 2 lshift + ;
: 256*      8 lshift ;
: 640*      80* 8* ;
@ </p>

<h1>50  Keyboard Handling</h2>

@ Most computer systems rely on interrupts to handle keyboard input.  The basic idea involves a (semi-)intelligent peripheral, the keyboard, operating completely asynchronously to the host computer.  When the user presses or releases a key, the keyboard somehow alerts the host computer to read the event right away.  This often takes mere microseconds to accomplish, even on processors with the slowest interrupt response times.  It depends extensively on humans being much slower than the electronics used to report on the user's activities.</p>

<h2>50.1  Keyboard Queue</h3>

@ The Kestrel-2, however, differs from the norm.  The J1 microprocessor lacks support for interrupts, forcing both software and hardware engineer alike to approach the problem of timely delivery of keyboard events differently.  With the Kestrel, whenever a user presses or releases a key, the appropriate event appears in a temporary queue <i>immediately</i>, assuming enough room exists to do so.  The queue exists in hardware, so the microprocessor needn't concern itself tending to the queue.  Up to fifteen bytes of event data may exist in the queue before information loss occurs.  Considering how slowly the user types in relation to the host processor, we consider this depth effectively infinite.</p>

@ The queue indicates whether or not data exists by setting a flag, namely bit 15, in its I/O register.</p>

<<PS/2 Keyboard Driver>>=
: available?    $FFFE @ 0< ;
@ %def available?

Given that at least one byte of data remains available for reading, bits 7-0 of the register contains the value of interest.</p>

<<PS/2 Keyboard Driver>>=
: mbc           $FFFE @ $00FF and ;
@ %def mbc

Reading from the keyboard I/O port will <i>not</i> dequeue the byte.  You can read it repeatedly as often as you want, and it will continue to return the same head of the queue over and over.  This might differ from most hardware-implemented queues, <i>precisely because</i> the J1 lacks interrupts.  We need the ability to poll for data without fear of destroying any data that might already exist in the queue.</p>

@ This leaves the problem of how one actually dequeues the keyboard queue.  We do this by writing any value back to the I/O register.  For the purposes of dequeueing, any value will do.  However, since two bits also control drivers to the PS/2 data and clock lines, we choose to use a fixed value guaranteeing that our local drivers are disabled.</p>

<<PS/2 Keyboard Driver>>=
: ack           $0300 $FFFE ! ;
@ %def ack

Given this simple interface to the keyboard hardware, writing an event handler for the keyboard becomes trivial.</p>

<<PS/2 Keyboard Driver>>=
: keyboard      available? if mbc filter ack then ;
@ %def keyboard
</p>

<h2>50.2  PS/2 Key Code Computation</h3>

@ A PS/2 keyboard communicates with its host computer via a serial communications link, not entirely unlike an RS-232 interface.  It does so using variable-length messages to indicate various events.  For example, if a keyboard sends the code [[$5A]], we know that the [[RETURN]] key was pressed (note the distinction between [[RETURN]] and [[ENTER]] on the numeric key-pad).  However, if we receive the sequence [[$F0 $5A]], we know that the button was released.  Since [[RETURN]] and [[ENTER]] essentially perform the same function now-a-days, it makes sense that they generate similar messages for their respective pressed and released states.  However, we can distinguish the two keys based on yet another message component: the [[$E0]] prefix, which prepends all <q>extended</q> key identifiers.  For example, [[$E0 $5A]] indicates that the [[ENTER]] key was pressed, while [[$F0 $E0 $5A]] indicates it was released.</p>

@ As these so-called <i>make/break codes</i> (hence the name [[mbc]] above) pour into the Kestrel, we essentially filter the raw feed, making sure to parse the multi-byte messages into something more manageable, namely single words we call <i>keycodes</i>.</p>

@ The single-byte PS/2 MBC represents the most basic keycode.  However, not knowing whether the single byte appears as a component of a larger packet, we need to keep a flags variable handy to remember the extension state of the MBC we're currently dealing with.</p>

<<PS/2 State>>=
variable s
@

We then merge that in with all bytes that look like single-byte messages.  Once keycode handling completes, we make sure to reset the keyboard state to ensure a clean slate for subsequent keyboard events.</p>

<<PS/2 Keycode Filter>>=
: filter        -$E0 -$F0 s @ or keycode 0 s ! ;
@ %def filter

Referring back to [[ui]] above, you'll notice that we reset the PS/2 keyboard state to zero every time the editor takes control of the machine.  This ensures the computer and the user share a common expectation of the state of the computer keyboard.</p>

@ What if a received byte <i>is</i> either an extension flag or a break flag?  We simply set the appropriate flags in [[s]], and eat the byte.  I can't think of any reason to invoke the [[keycode]] handler knowing we don't yet have a full keyboard message in hand.</p>

<<PS/2 Flag Intercepts>>=
: -$E0          dup $E0 xor if exit then $0100 s @ or s !  r> 2drop ;
: -$F0          dup $F0 xor if exit then $8000 s @ or s !  r> 2drop ;
@ %def -$E0 -$F0

Notice that we use bit 8 to indicate an extended keycode.  If we wanted to, we could logically-AND all keycodes with [[$00FF]] to share left- and right-hand side [[SHIFT]], [[CTRL]], [[ALT]], [[Windows]], and the numeric keypad keys with their left-handed counterparts.  Likewise, we use bit 15 to indicate a switch break event.  This lets one use [[0< IF]] in Forth, or its equivalent, to concisely differentiate between make and break codes.</p>

<h2>50.3  User Keyboard Interface</h3>

@ A human operator interacts with Preen via the keyboard, so somewhere the program must dispatch commands based on which key event occurs.  Preen contains a fairly restricted set of keyboard inputs, including cursor control, the ENTER key, and valid hexadecimal digits.</p>

<<Keyboard dispatcher>>=
: dispatch      -up -down -left -right -enter -valid drop ;
@ %def dispatch

Since most of these inputs result in the cursor moving on the screen, we need to make sure we wrap our dispatcher with logic to turn the cursor off and back on afterwards.</p>

<<Keyboard dispatcher>>=
: keycode       coff dispatch blink ;
@ %def keycode

If we detect a cursor movement operation, we call into the screen editor to adjust the cursor location accordingly, and take no further action.</p>

<<Cursor Movement Dispatch>>=
: -up           dup $0175 xor if exit then up r> 2drop ;
: -down         dup $0172 xor if exit then down r> 2drop ;
: -left         dup $016B xor if exit then left r> 2drop ;
: -right        dup $0174 xor if exit then right r> 2drop ;
@ %def -up -down -left -right

When the user presses [[ENTER]], the user's session with the screen editor completes, commencing the execution of whatever command appears on the line with the cursor.</p>

<<ENTER dispatch>>=
: -enter        dup $005A xor if exit then complete r> 2drop ;
@ %def -enter

We'll talk more about [[complete]] and how it actually executes command later.</p>

@ When a user presses a valid hexadecimal digit, we would like to make that digit appear where the cursor resides, and bump the cursor to the left.  Recall that our display buffer doubles as our text input buffer, so merely [[emit]]ing a character suffices to make it eligible for input later.</p>

<<Valid Hexadecimal Digit Handler>>=
: kbhit         >ascii emit 2drop drop ;
@ %def kbhit

We need to take care, though, for the PS/2 driver hands us <i>keycodes</i>, and the text buffer consumes <i>ASCII</i>.  We use a look-up table to perform the conversion, since keycodes make up an unordered set.</p>

<<Convert keycode to ASCII>>=
: >ascii        rawcodes - cookedcodes + @ ;
@ %def >ascii

An unordered keycode becomes an ordered rawcode via the following look-up table.</p>

<<Keycode to Rawcode Lookup Table>>=
create rawcodes
    $0045 , $0016 , $001E , $0026 ,
    $0025 , $002E , $0036 , $003D ,
    $003E , $0046 , $001C , $0032 ,
    $0021 , $0023 , $0024 , $002B ,
@ %def rawcodes

Knowledge of PS/2 keycode values shows that I've listed the sixteen hexadecimal digits, from <q>0</q> through <q>F</q>, in this table.  When we receive a keycode, we look it up in this table to see if it exists.  If not, we know the key isn't a hex digit, and we ignore it.</p>

<<Rawcode Table Scanner>>=
: -match        2dup @ xor if exit then kbhit r> r> 2drop r> r> drop ;
: r             -match 2 + ;
: -found        r r r r  r r r r  r r r r  r r r r ;
: -valid        dup rawcodes -found 2drop ;
@ %def -valid

Assuming we find a match in the [[rawcodes]] table, [[>ascii]] converts the address in [[rawcodes]] into a relative offset into [[cookedcodes]], which contain the corresponding ASCII codes for the hexadecimal digits.</p>

<<Rawcode to ASCII Lookup Table>>=
create cookedcodes
    $0030 , $0031 , $0032 , $0033 ,
    $0034 , $0035 , $0036 , $0037 ,
    $0038 , $0039 , $0041 , $0042 ,
    $0043 , $0044 , $0045 , $0046 ,
@ %def cookedcodes

This results in two arrays which work together to translate keycodes into their ASCII equivalents.</p>

<table width="50%">
 <tr>
  <th>keycode</th>
  <th>ASCII</th>
 </tr>
 <tr><td>[[$0045]]</td><td>[[$0030]]</td></tr>
 <tr><td>[[$0016]]</td><td>[[$0031]]</td></tr>
 <tr><td>[[$001E]]</td><td>[[$0032]]</td></tr>
 <tr><td>[[$0026]]</td><td>[[$0033]]</td></tr>
 <tr><td>[[$0025]]</td><td>[[$0034]]</td></tr>
 <tr><td>[[$002E]]</td><td>[[$0035]]</td></tr>
 <tr><td>[[$0036]]</td><td>[[$0036]]</td></tr>
 <tr><td>[[$003D]]</td><td>[[$0037]]</td></tr>
 <tr><td>[[$003E]]</td><td>[[$0038]]</td></tr>
 <tr><td>[[$0046]]</td><td>[[$0039]]</td></tr>
 <tr><td>[[$001C]]</td><td>[[$0041]]</td></tr>
 <tr><td>[[$0032]]</td><td>[[$0042]]</td></tr>
 <tr><td>[[$0021]]</td><td>[[$0043]]</td></tr>
 <tr><td>[[$0023]]</td><td>[[$0044]]</td></tr>
 <tr><td>[[$0024]]</td><td>[[$0045]]</td></tr>
 <tr><td>[[$002B]]</td><td>[[$0046]]</td></tr>
</table>

<h1>60  Interpreting Commands</h2>

<h2>60.1  Parsing the Command Name</h3>

@ When the user presses [[ENTER]], whatever line the cursor resides on provides the input to a very simple evaluator.</p>

<<Command Interpreter>>=
: complete      y @ 80* TdfChrMtx @ + tib !  80 #tib !  0 >in !  interpret display ;
@ %def complete

[[interpret]] takes its input from the buffer pointed to by [[tib]], whose maximum length resides in [[#tib]].  The interpreter keeps track of where it's at through the [[>in]] variable.  At all times, 0 &le; [[>in]] &le; [[#tib]].</p>

<<Interpreter State>>=
variable tib
variable #tib
variable >in
@ %def >in #tib tib

Like shell commands in Windows or Unix, commands consist of a name followed optionally by space-delimited arguments.  The interpreter concerns itself only with the command name.  We commence execution by pushing the command's address onto the CPU's return stack, and literally <q>returning</q> to it.</p>

<<Command Dispatch>>=
: interpret     word +valid find >r nop, ;
@ %def interpret

Command names share the same lexing rules as Forth words (e.g., white-space delimited strings of non-whitespace characters).  Words may optionally have whitespace ahead of it, so we make sure to skip over it, if possible.  After skipping over non-whitespace characters too, we can subtract the starting address from the ending addresses to arrive at the word's length.</p>

<<Forth Word Lexing>>=
: ws            -eoln ws? if 1 >in +! recurse exit then ;
: txt           -eoln ws? if exit then 1 >in +! recurse ;
: word          ws pch txt pch over - ;
@ %def word

I define whitespace as any ASCII character in the range [$00, $20].</p>

<<Whitespace check>>=
: ws?           ch $21 - 0< ;
@ %def ws?

While scanning text for (non-)whitespace characters, we want to make sure we confine ourselves to the current line.  If we don't do this, we can overrun memory if the cursor sits at the very bottom of the screen.  Even if it's not, we can get odd behaviors in cases where text appears to wrap around the screen's edges.  This latter condition never happens in Preen, but the former has caused problems while the software was under development.  Note that the expression [[>in @ #tib @ -]] becomes positive precisely when [[>in]] &ge; [[#tib]].</p>

<<End-of-line check>>=
: -eoln         >in @ #tib @ - 0< if exit then r> drop ;
@ %def -eoln

As indicated above several times, we use the text display character matrix directly as a buffer.</p>

<<Matrix Character Fetch>>=
: pch           >in @ tib @ + ;
: ch            pch c@ ;
@ %def ch pch

What if the line contains only whitespace?  In this case, our command word will have a zero length.  Without a command to execute, we can only do nothing.</p>

<<Command Length Check>>=
: +valid        dup if exit then r> drop ;
@ %def +valid
</p>

<h2>60.2  Finding the Command's Implementation</h3>

@ Although [[word]] properly returns the length of the string it's parsed, we only use it as a flag to see whether or not a line was empty or not.  All command names in Preen occupy a single word of memory, enabling [[xor]] to service as a crude string comparison operator.  It similarly allows us to fetch whole names from memory using only [[@]].</p>

@ We start our search by first discarding the length of the word, and fetching the first two characters (space padded due to how the display memory works).  If no matching command exists, we default to the routine which causes a display refresh.</p>

<<Map Command Name to Executable Address>>=
: find          drop @ -found drop display' @ ;
@ %def find

<<Display Routine Address>>=
create display'
    ' display >body 2/ ,
@ %def display'

We start our search by attempting to index our command name in a look-up table.  Since Preen supports so few commands, we hard-wire the number of items to search.</p>

<<Command Search>>=
: -found        wtab -fnd -fnd -fnd -fnd -fnd nop, ;
@ %def -found

The table of command names includes [[D+]], [[R+]], [[M=]], [[M+]], and [[GO]].</p>

<<Command Name Table>>=
create wtab
    $442B , $522B , $4D3D , $4D2B , $474F ,
@ %def wtab

When we find a hit in [[wtab]], [[-fnd]] uses [[proc]] to read the corresponding procedure address out of the procedure table:</p>

<<Command Search Step>>=
: proc          wtab - wproc + @ ;
: -fnd          2dup @ xor if 2 + exit then nip proc r> r> 2drop ;
@ %def -fnd proc

<<Command Procedure Table>>=
create wproc
    ' D+ >body 2/ ,  ' R+ >body 2/ , ' M= >body 2/ , ' M+ >body 2/ , ' GO >body 2/ ,
@ %def wproc

<h2>60.3  Commands</h2>

@ We already saw the [[GO]] command implementation earlier in this document.  Therefore, I'll focus on the [[D+]], [[R+]], [[M=]], and [[M+]] commands next, all of which accept arguments and take some action based on those arguments.</p>

@ Perhaps the simplest commands to understand are the [[D+]] and [[R+]] commands.  Each of these commands consumes nine arguments: a byte indicating an offset from some fixed buffer address, and eight words of data to store starting at that offset.  So, e.g., executing [[D+ 10 1111 2222 3333 4444 5555 6666 7777 8888]] places the value [[$1111]] at the data stack's 16th byte, [[$2222]] at the 18th byte location, and so on.  The only difference between [[D+]], [[R+]], and [[M+]] concerns where the first byte of data appears in memory.</p>

<<Memory Store Commands>>=
: D+            nbr dstack + chg ;
: R+            nbr rstack + chg ;
: M+            nbr memptr @ + chg ;
@ %def D+ R+ M+

Note that both [[D+]] and [[R+]] operate on a well-known buffer (namely, the data and return stack buffers written to by [[breakpoint]] and restored from in [[GO]]).  [[M+]], however, operates on a buffer determined by the user at run-time via the [[memptr]] variable.  We set [[memptr]] using the [[M=]] command.</p>

<<Memory Pointer Change Command>>=
: M=            nbr memptr ! ;
@ %def M=

With all these commands, note that we accept a number as a parameter.  We expect a small enough number that it fits in a single CPU cell.  While converting the number, we use [[v]] as a temporary accumulator.</p>

<<Grab a numeric parameter>>=
: nbr           0 v ! word hex>n v @ ;
@ %def nbr

<<Numeric Accumulator>>=
variable v
@ %def v

Conversion procedes one hexadecimal digit at a time, for as long as we have digits to convert.  We trust the user to not provide us with garbage (e.g., numbers more than four hex digits in length).  Note that it's impossible to provide non-hex digits because the keyboard interface discards them out of hand.</p>

<<Convert a string into a number>>=
: hex>n         dup if d -1 + swap 1 + swap recurse exit then 2drop ;
@ %def hex>n

For each digit, we shift the accumulator left four bits, then logically-OR the equivalent binary value of the hexadecimal digit.</p>

<<Accumulate a single hex digit>>=
: digit         -48 + dup -10 + 0< if exit then -7 + ;
: d             over c@ digit v @ 4 lshift or v ! ;
@ %def d

For the [[D+]], [[R+]], and [[M+]] commands, we consume eight additional numbers, each placed consecutively in memory at successive addresses.  at successive addresses.</p>

<<Store Data>>=
: w             nbr over !  2 + ;
: chg           w w w w w w w w drop ;
@ %def chg
</p>


<h1>70  Primitives</h1>

@ Boolean predicates, such as <i>less than zero</i>, occur frequently enough that they require their own definitions.</p>

<<Primitives>>=
: 0<        $8000 and ;
@

Not fitting in particularly well elsewhere, some mathematical operations are needed to make the machine language monitor work.  We start with determining the maximum or minimum value.</p>

<<Primitives>>=
: max       2dup - 0< if nip exit then drop ;
: min       2dup - 0< if drop exit then nip ;
@

Until now, we haven't addressed some of the more fundamental aspects of the J1 as it works with the Kestrel-2 hardware.  We start with the fetch operator, where we rely on software to extend the operation to two instruction cycles.  This provides the block RAMs on the Xilinx FPGA I'm using enough time to set up their address bus and deliver the data.  The J1, implementing an essentially asynchronous memory bus architecture, would work great as-is if we were talking to, say, a 62256 static RAM chip.  In this case, as soon as the address bus changes, the 62256 would take, say, 100ns to update its data bus.  Provided the J1 were clocked with a period at least as long as 100ns, the J1 could realize single-cycle read performance.  However, the RAMs used in the FPGA are <i>synchronous</i> RAMs, and are clocked off the processor clock for simplicity.  Therefore, as soon as the address bus changes, we need to wait at least one cycle for the block RAMs to catch up.</p>

@ As it happens, a J1 subroutine call takes exactly one cycle.  We define [[@]] as a subroutine, consisting of precisely one instruction ([[@,]]), which both fetches and returns to the caller in a single cycle as well.  Thus, we achieve our desired two-cycle execution performance for [[@]].</p>

<<Primitives>>=
: @     @, ;

@ The J1 also requires, albeit for different reasons, two cycles to effect the [[!]] instruction.  The first instruction strobes the CPU's [[D_WE_O]] signal, telling the block RAMs to write the data instead of reading it, while the second cleans up the stack.  Best implemented as a macro, we find the definition for [[!]] in the assembler, [[asm.f]], rather than here.</p>

@ The J1 can only access memory 16-bits at a time; accessing individual 8-bit quantities, important for character manipulation or some graphics operations, requires that we perform bit-field manipulations.  Applications should make every effort to minimize the use of character accessors, however, as these can incur significant program overheads.  [[c@]] consumes somewhere in the vicinity of 10 clock cycles, while [[c!]] consumes around 15.</p>

<<Primitives>>=
: c@        dup 1 and if @ 255 and exit then @ 8 rshift 255 and ;
: even!     swap 8 lshift over @ 255 and or swap ! ;
: odd!      swap 255 and over @ $FF00 and or swap ! ;
: c!        dup 1 and if odd! exit then even! ;

@ As you can see above, even addresses correspond to bits 15...8 of a word, while odd addresses correspond to bits 7...0.  This maintains consistency with how the video interface refreshes the display, and thus, simplifies graphics software by eliminating byte-swapping logic.</p>

@ While somewhat ambiguous with the category of mathematical procedure, [[+!]] proves useful for performing basic addition on a memory-resident variable without having to explicitly manage addresses.  Since it depends on [[@]] and [[!]] for its operation, we place its definition here.</p>

<<Primitives>>=
: +!            2dup @ + swap ! drop ;
@ </p>
