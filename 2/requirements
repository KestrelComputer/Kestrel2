*** TO DO ***
---
AS A        coder
I WANT      the ability to prune away the names belonging to internal/implementation-specific words
SO THAT     we don't waste precious memory space with unnecessary word names.
---
AS A        symbol table
I WANT      to let the compiler alter the immediacy flag
SO THAT     we can compile primitives and other syntax into the target run-time image.
---
AS A        coder
I WANT      negative numbers to be supported
SO THAT     I don't have to convert everything to unsigned hexadecimal form myself.
---

*** IN PROGRESS ***

*** DONE ***

AS A        coder
I WANT      an 8192 cell buffer into which software is compiled
SO THAT     I need not worry about overflowing the buffer or interfering with host colon-definitions.
---
AS A        coder
I WANT      all references to the target compilation buffer to be bounds-checked
SO THAT     I don't crash the compiler when making a wild pointer reference.
---
AS A        coder
I WANT      the phrase "0 org" to reset the compilation pointer to zero
SO THAT     I can create a bootable image for the J1 and other customized processors.  The J1's first instruction is assumed to be located at address 0.
---
AS A        symbol table
I WANT      to record a symbol's name, address, and immediacy flag
SO THAT     the interpreter or compiler can locate or invoke the implementation of a word.
---
AS A        symbol table
I WANT      to keep a word's metadata separate from its code
SO THAT     the processor can find executable code at its specially reserved memory locations (e.g., address 0).
---
AS A        symbol table
I WANT      to not artificially constrict the length of a name
SO THAT     the user is free to use whatever names they want.  Shorter is recommended, of course.
---
AS A        compiler
I WANT      "," to populate the next location in the dictionary
SO THAT     I don't need to keep track of the compile pointer manually.
---
AS A        coder
I WANT      "defer foo" to create a deferred Forth word foo
SO THAT     I can invoke foo at will, whose semantics will be specified at run-time.
---
AS A        compiler
I WANT      "defer foo" to populate the dictionary with a header for "foo" followed by a nil jump
SO THAT     "blah is foo" can find where to lay down a new jump target.
---
AS A        coder
I WANT      "' blah is foo" to configure foo to jump to blah
SO THAT     I can alter the semantics of foo at run-time, or implement interrupt vectors.
---
AS A        compiler
I WANT      "is foo" to alter foo's first instruction to jump to another word whose execution token is taken from the stack
SO THAT     I can implement vectors without having to manually compute addresses to poke.
---
AS A        compiler
I WANT      some mechanism to know when I've exhausted the vocabulary's wordlist
SO THAT     I don't crash when the user asks me to compile or execute a word which hasn't been defined yet.
---
AS A        compiler
I WANT      ":" to create an unrevealed dictionary entry
SO THAT     ";" can reveal it at the right time.
TEST:       After : foo, a dictionary entry named foo must exist.
TEST:       After : foo, the foo entry must not be revealed.
---
AS A        coder
I WANT      ";" to terminate a colon definition in progress
SO THAT     I can define more than one word.
TEST:       After : foo ;, the foo entry must be revealed.
---
AS A        coder
I WANT      ":" to begin compiling a new Forth word with ANS Forth semantics followed as closely as possible
SO THAT     I don't have to hand-assemble code myself.
TEST:       After : foo ;, ', foo definition t@ should equal $700C, and THERE = old_THERE+2.
---
AS A        coder
I WANT      non-immediate words to be compiled as CALLs
SO THAT     I can compose functionality by name in the tightest space possible.
TEST:       defer foo
            : bar foo foo ;
            ', bar definition t@ should be a CALL instruction
---
AS A        coder
I WANT      host-defined "target immediate" words to be invoked at compile-time
SO THAT     I can implement primitives, loops, and other syntax.
TEST:       Define a host word xyz
            : foo xyz ;
            somehow check to see if xyz executes.
---
AS A        compiler
I WANT      ";" and "EXIT" to convert a previous CALL to a JMP
SO THAT     return stack resources are conserved to the greatest extent.
TEST:       defer foo
            : bar foo exit foo ;
            ', bar definition 0 + t@ should be a JMP instruction
            ', bar definition 2 + t@ should be a JMP instruction
---
AS A        compiler
I WANT      ";" to implicitly compile "EXIT"
SO THAT     I don't have to explicitly return from each definition.
TEST:       : foo + ;
            ', foo definition 2 + t@ should be the opcode for a return ($700C)
---
AS A        compiler
I WANT      RECURSE to compile a call to the current definition
SO THAT     I can write recursive routines and TCO'ed loops.
TEST:       : foo recurse ;
            ', foo definition t@ should be a JMP or CALL to itself
---
AS A        coder
I WANT      IF and THEN implemented
SO THAT     I can write code which reacts to its runtime environment.
TEST:       : foo if recurse then ;
            ', foo definition t@ should be a 0BRANCH instruction to definition+2.
---
AS A        compiler
I WANT      tail-call optimization to not cross basic block boundaries
SO THAT     forward-references resolve to proper instruction sequences.
OTHERWISE   instruction semantics will work only for the consequent of an IF,
            but not for the alternate.
TEST:       : foo if recurse then ;
            ', foo definition 2 + t@ should be a CALL instruction, while
            definition 4 + t@ should be an explicit RETURN instruction.
---
AS A        coder trying to compile the first milestone
I WANT      the primitives implemented: + xor ! drop @ dup over recurse exit if then
SO THAT     I can compile a high-level representation of the first program ks ever ran correctly.
TEST:       Compiles img.f correctly.  Manual testing OK.
---
AS A        coder
I WANT      words not found in the dictionary to be treated as a number
SO THAT     I can specify numeric literals easily.
---
AS A        coder
I WANT      words not found in the dictionary AND not interpretable as a valid number to throw a compile-time error
SO THAT     I don't waste time discovering typos and thinkos at run-time.
TEST:       16 base ! : foo 0Z ;  should throw an exception.  Make sure to restore BASE.
---
AS A        coder
I WANT      the word TARGET to reconfigure the host Forth environment to compile to the J1 space
SO THAT     I can control when : compiles to the target or to the host.
TEST:       Incomplete, open-ended test.
            TARGET : foo ; should bump THERE by one instruction, while
            HOST   : foo ; on its own should not.
---
AS A        coder
I WANT      the word HOST to revert back to host-mode Forth.
SO THAT     after target compilation, I can invoke other functions and scripts in the context of the host.
TEST:       (see above)
---
AS A        coder
I WANT      numbers starting with $ to be treated as hexadecimal, regardless of BASE
SO THAT     I don't have to futz with BASE, an error-prone operation.
TEST:       : foo $0A ;
            ', foo definition t@ 10 =
---
AS A        coder
I WANT      an assembler which translates the source code in a file img.f into a raw binary image in a file namd img
SO THAT     I can launch ks without having to translate initial programming into C statements by hand.
