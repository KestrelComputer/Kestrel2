<div class="blogArticleTitle">
 Preen Release 1A: a Kestrel-2 Monitor
</div>
<div class="blogArticleTimestampAuthor">
 <div class="blogArticleAuthor">Samuel A. Falvo II<br>kc5tja -at- arrl.net</div>
 <div class="blogArticleTimestamp">2011 Aug 27 17:34 PDT</div>
</div>
<div class="blogArticleLead">
 <p>
  Bringing up a new computer from scratch poses a chicken-and-egg problem.  When the system software under development unexpectedly fails, no extant means exists to determine hardware or software culpability.  A reference program written to run under both an emulator and physical hardware can help isolate causes of failure.  Software which fails on physical hardware but not in an emulated environment justifies further investment in debugging the hardware.
 </p>
 <p>
  Ideally, the reference program should exercise, at a minimum, all peripherals required to support an interactive user experience.  A personal computer without a user interface serves no useful purpose.  A simple monitor program provides a means to exercise a video display output, keyboard input, and some more esoteric properties of the host CPU.  Further, a monitor may provide a useful debugging aid for diagnosing problems when higher-level software or hardware components fail.
 </p>
</div>
<div class="blogArticleBody">

<h1>10  Binary Image Generation</h1>
@ Each ROM image source file is a regular Forth script.  We start Forth using something like <q>gforth [[preen.f]]</q>, and rely on the implementation of [[preen.f]] to do the right thing.  Since we're going to be assembling code for the target processor, we need to load the assembler into the host's dictionary.</p>

<<Load target development>>=
include asm.f
@

When loaded, the assembler's internal data structures will be in an unknown state.  We need to reset the assembler state.</p>

<<Load target development>>=
0symtab
@

The J1 processor begins its execution at address zero in its memory map.  Since the assembler doesn't yet know what code we're going to place further on in memory, we're going to compile a forward jump.  The [[DEFER]] keyword is the best way I know how to achieve this.  Later, when we're done assembling, we can patch up this vector with the proper entry point address.</p>

<<Origin directive>>=
0 org
<<Reset vector>>=
defer _main
@ %def _main
<<Patch reset vector>>=
' breakpoint is _main
@

Once everything's been assembled, we create the ROM file on the host computer, and terminate the Forth session.</p>

<<Emit binary file>>=
host romfile  bye
@

All other sections refer to target-specific code, so let's make sure we configure the Forth environment to produce software in the target.</p>

<<Origin directive>>=
target
@

In summary, the top-level layout of the program follows:</p>

<<preen.f>>=
<<Load target development>>
<<Origin directive>>
<<Reset vector>>
<<Primitives>>

<<Text Display Facility>>

<<System software state>>
<<Screen Editor>>
<<Breakpoint handler>>

<<TDF Example Code>>
<<Patch reset vector>>
<<Emit binary file>>
@

<h1>20  Breakpoints</h1>
@ The J1 processor as used in the Kestrel-2 lacks interrupts; therefore, the processor cannot reasonably respond to such things as illegal memory accesses or malformed instructions.  Control transfers to the monitor, like all other software on the J1 processor, through explicit control flow instructions.  In this case, applications invoke a <i>breakpoint</i>.</p>

@ A breakpoint behaves like a software-defined interrupt.  The application containing a breakpoint instruction <i>trusts</i> the processor state will remain unaltered before and afterwards.  (Of course, the user has the option of altering the state of the running program.)  In order to display the machine state to the user, it must be preserved in memory somewhere, so we'll need some storage space.</p>

<<System software state>>=
: dstack        $4000 ;
: rstack        dstack 64 + ;
@ %def dstack rstack

You'll notice that no space exists for the program counter.  Since the breakpoint handler will be invoked via a [[CALL]] instruction, it already exists at the top of the return stack.  <i>Note that this implies that only 31 return stack elements are preserved by the breakpoint handler.</i>  Therefore, Preen will likely cause any program which depends on the availability of all 32 return stack registers to crash.</p>

@ The J1 provides the programmer with <i>33</i> data stack registers.  These include [[T]], the top of the stack which feeds the J1's first ALU input, and 32 other stack registers.  However, in the state above, we reserve only 32 slots.  Since the J1 lacks an instruction to store its state in a memory location, we need to use [[!]] to store to memory the state of the data stack.  Pushing the address that [[!]] will store to necessarily causes the 33rd stack cell to disappear, <i>thus leaving only 32 of the 33 data stack items available for inspection.</i>  Preen will likely cause any program which depends on the availability of all 33 data stack registers to crash.</p>

@ When the breakpoint hits, Preen must assume the program uses all data and return stack items.  Therefore, the breakpoint handler must free up enough stack space to function.  First we free up a handful of data stack items, which will in turn enable us to free up a few return stack slots.  Once complete, we can start using higher-level Forth definitions again.  Note we avoid invoking [[dstack]] and [[rstack]] because we don't want to disturb the state of the return stack just yet.</p>

<<Breakpoint handler>>=
<<ds!>>
<<rs!>>
: breakpoint
  $4000 !  $4002 !  $4004 !  $4006 !
  r> $4040 !  r> $4042 !  r> $4044 !  r> $4046 !
@ %def breakpoint

Now that we have some play in the two stacks, we can rely on higher-level definitions to save the processor state without having to explicitly list all the memory addresses by hand.</p>

<<Breakpoint handler>>=
  dstack 8 + ds!  rstack 8 + rs!
@

[[ds!]] will store 28 cells of the interrupted program's data stack.  Remember that [[breakpoint]] already stored four data stack items manually at the start of its definition, bringing the total number of data stack items saved to 32.</p>

<p>
<<ds!>>=
: c         2dup ! 2 + nip ;
: 7c        c c c c c c c ;
: ds!       7c 7c 7c 7c drop ;
@ %def ds!

Committing the data stack to memory frees up the data stack &mdash; the monitor may now utilize all 32 cells if it wishes.  We still need to preserve the return stack, however.  We need a somewhat different strategy for the return stack, because invoking [[rs!]] itself uses the return stack.  Since [[>r]] is pushing a value onto the R-stack, we cannot invoke [[>r ;]] without crashing.  The [[;]] would try to pop from the R-stack at the same time as [[>r]] is pushing, corrupting the R-stack in the process.  We nullify tail-call optimization using [[nop, ;]]</p>

<<rs!>>=
: rs!       r> swap <<write 28 cells>> drop >r nop, ;
@ %def rs!

Regrettably, we cannot rely on subroutine calls while we're manipulating the return stack, so we need to inline 28 cell stores directly.</p>

<<write 28 cells>>=
<<write 7 cells>>
<<write 7 cells>>
<<write 7 cells>>
<<write 7 cells>>
@

<<write 7 cells>>=
<<write a cell>>
<<write a cell>>
<<write a cell>>
<<write a cell>>
<<write a cell>>
<<write a cell>>
<<write a cell>>
@

<<write a cell>>=
r> over ! 2 +
@

Once both the data and return stacks have been committed to memory, the entire state of the interrupted program avails itself for inspection.  Recall that the interrupted program's instruction pointer resides in the cell at [[rstack]]+0.  This leaves [[breakpoint]] with only one last task to perform: kick off the monitor's user interface.</p>

<<Breakpoint handler>>=
  scrn0 page .banner commit ui ;
@ </p>

<h1>30  Displaying the Program State</h1>

@ Before the user can interact with the debugger, the user needs to see what the program's state is.</p>

<h1>40  Screen Editor Interface</h1>

@ Wouldn't it be great if you could just print a form to the screen, which the user can then fill in or change, with the same level of ease as you would <q>Hello world</q>?  With a typical command-line interface, such as those found in Unix or Windows systems, you cannot accomplish this.  At best, you can print out the data the user is interested in, along with a small menu of commands to manually enter which affects this data.  Three solutions exist to overcome this problem.  You could rely on some kind of library like [[curses]] or [[ncurses]], but this often deleteriously changes the complexity of the program.  You could require the user to type, by hand of course, commands which affect various fields of the data being manipulated, but when doing this frequently, it becomes laborious and error-prone.  Finally, you can rely on a <i>full screen editor</i> to grant the user the power to take previously printed text as future input to a program.  Today's most popular command-line interfaces still assume that the user's interface consists of a line printer terminal, while the full-screen editor described herein takes advantage the 2-D nature of contemporary display devices.</p>

@ If you used an Atari or Commodore 8-bit computer, such as the Atari 400 or the Commodore 64, you actually already used a full-screen editor.  Commodore users might remember the trick of listing a directory with:</p>
<pre>LOAD<q>$</q>,8
LIST</pre>
@ then cursoring to the desired program, and changing the line by typing [[LOAD]] at the left-hand column and [[,8:]] or [[,8,1:]] on the right-hand side of the program's name.  This is a fine example of using one command to produce a kind of menu which, through screen editing, becomes a template to easily select a program for execution, despite no menu code actually existing anywhere in the disk drive or host computer ROM image.  I'm sure Atari users will have similar use-cases.</p>

@ The Kestrel-2 monitor software will rely on a full-screen editor to provide its user interface, for several reasons.  First, its interface primarily takes the shape of a form, with specific fields for data and return stacks, for memory, and for action-oriented controls such as <q>execute.</q>  The user is expected to <q>just change</q> appropriate rows of fields as needed, then pressing [[ENTER]].  As implemented, the only real disadvantage is the user needs to press [[ENTER]] for each row he changes.</p>

@ The monitor's screen editor offers the following capabilities:</p>
<ol>
 <li>Move the cursor about the screen</li>
 <li>Insert or overwrite text on a line</li>
 <li>Delete text to the left (backspace)</li>
 <li>Delete text to the right</li>
 <li>Submit a line for program processing</li>
</ol>
@ Correspondingly, the screen editor's layout in memory follows a similar form.</p>
<<Screen Editor>>=
<<Screen Editor State>>
<<Screen Editor Cursor Confinement>>
<<Screen Editor Cursor Movement>>
<<Screen Editor Blinky Cursor>>
@

<h2>40.10  Moving the Cursor</h2>

@ Through the editor interface, the cursor has free range over the screen.  The Kestrel-2 provides a 640&times;200 graphic display, which when broken into 8 pixel by 8 pixel tiles, yields an 80&times;25 display.  When moving the cursor, we want to make sure that its coordinates always remains somewhere on the screen.  It should be noted that our screen editor will be more simple than those used in Atari and Commodore computers; because everything fits on one screen, we will not support scrolling the display.</p>

<<Screen Editor State>>=
variable x
variable y
@

Pressing one of the four cursor keys will cause the cursor to move about the screen in the desired direction.  We implement this by updating the [[x]] and [[y]] variables, making sure to confine them to the appropriate bounding rectangle.  Make sure you turn the cursor off ([[coff]], defined later) before altering the cursor location, or you risk cosmetic problems.</p>

<<Screen Editor Cursor Movement>>=
: up        -1 y +! confine ;
: down       1 y +! confine ;
: left      -1 x +! confine ;
: right      1 x +! confine ;
@

Confinement ensures the cursor remains on the visible character matrix at all times.</p>

<<Screen Editor Cursor Confinement>>=
: confine   x @ 0 max 79 min x !   y @ 0 max 24 min y ! ;
@

<h2>40.20  Inserting and Overwriting Text</h2>

<h2>40.30  Deleting Text to the Left</h2>

<h2>40.40  Deleting Text to the Right</h2>

<h2>40.50  Submitting a Line of Text</h2>

<h2>40.60  Blinking the Cursor</h2>

@ I have discovered through my own experiences that a text cursor should blink fairly rapidly, and should cover the entire character cell.  Vertical bar cursors, such as those found in most graphical environments, get lost too easily.  Slowly blinking cursors don't seem to have the desired effect of telling me <i>at a glance</i> where my insertion point is.  Static solid block cursors, including those which rely on reverse video, too often blur into the background for me, leaving me effectively blind to them.  The human eye is most sensitive to motion in both the foreground and the periphery, so it makes sense to exploit that feature of human vision.  I chose to blink the cursor at a rate of four times every second.  My eye appreciates this blink rate the best.</p>

@ We calculate the bitmap address of the glyph under the cursor by considering the cursor's current location.</p>

<<Screen Editor Blinky Cursor>>=
: address       y @ 640* x @ + $8000 + ;
@

We implement the text cursor by reversing the video of a given character glyph in the bitmap.  In addition, we'll toggle a flag in memory, so we know whether we've reversed the video or not.  This will come in handy for when we want to <q>turn off</q> the cursor.</p>

<<Screen Editor Blinky Cursor>>=
variable blst
: b             dup dup c@ invert swap c! 80 + ;
: blink         address b b b b b b b b drop  blst @ -1 xor blst ! ;
@

We know that [[blink]] is its own inverse, so turning off a cursor involves calling [[blink]] if, and only if, we know the video underneath the cursor has already been inverted.</p>

<<Screen Editor Blinky Cursor>>=
: coff          blst @ if blink then ;
@

<h2>40.70  Text Editor Main Loop</h2>

@ The text editor's main loop drives the blinking cursor as well as the keyboard interface.  I chose to blink the cursor four times every second, as my eye appreciates this blink rate the best.  It continues in this manner, blinking the cursor and responding to keyboard events, until the user presses the [[ENTER]] key, after which the editor returns the base address and length of the text line containing the cursor.  As a convenience to the user, the cursor is turned off, indicating no further input is required.</p>

This is a temporary definition for [[ui]].  Eventually, we want this, perhaps with a new name, to be the main loop for the editor.</p>

<<Screen Editor>>=
variable blct
: blinker       1 blct @ + dup 49152 xor if blct ! exit then drop blink 0 blct ! ;

variable s
create rawcodes
    $0045 , $0016 , $001E , $0026 ,
    $0025 , $002E , $0036 , $003D ,
    $003E , $0046 , $001C , $0032 ,
    $0021 , $0023 , $0024 , $002B ,
create cookedcodes
    $0030 , $0031 , $0032 , $0033 ,
    $0034 , $0035 , $0036 , $0037 ,
    $0038 , $0039 , $0041 , $0042 ,
    $0043 , $0044 , $0045 , $0046 ,
create scrn
    2048 allot

: clr           dup if swap 32 over c! 1 + swap -1 + recurse exit then 2drop ;
: page          TdfChrMtx @ 2000 clr  0 x !  0 y ! ;
: scrn0         scrn TdfChrMtx ! ;
: plot          TdfChrMtx @ y @ 80* x @ + + c! ;
: emit          plot right commit ;
: type          dup if over c@ emit -1 + swap 1 + swap recurse exit then 2drop ;
: cr            0 x ! down ;
: .banner       S" Kestrel Preen 1A" type cr cr ;
: >ascii        rawcodes - cookedcodes + @ ;
: kbhit         >ascii emit 2drop drop ;
: -match        2dup @ xor if exit then kbhit r> r> 2drop r> r> drop ;
: r             -match 2 + ;
: -found        r r r r  r r r r  r r r r  r r r r ;
: -valid        dup rawcodes -found 2drop ;
: -up           dup $0175 xor if exit then up r> 2drop ;
: -down         dup $0172 xor if exit then down r> 2drop ;
: -left         dup $016B xor if exit then left r> 2drop ;
: -right        dup $0174 xor if exit then right r> 2drop ;
: dispatch      -up -down -left -right -valid drop ;
: keycode       coff dispatch blink ;
: -$E0          dup $E0 xor if exit then $0100 s @ or s !  r> 2drop ;
: -$F0          dup $F0 xor if exit then $8000 s @ or s !  r> 2drop ;
: filter        -$E0 -$F0 s @ or keycode 0 s ! ;
: available?    $FFFE @ $8000 and ;
: mbc           $FFFE @ $00FF and ;
: ack           $0300 $FFFE ! ;
: keyboard      available? if mbc filter ack then ;
: ui...         blinker keyboard recurse ;
: ui            0 s !  ui... ;
@ </p>

<h1>100  Primitives</h1>
<h2>100.10  Mathematics</h2>
Boolean predicates, such as <i>less than zero</i>, occur frequently enough that they require their own definitions.</p>

<<Primitives>>=
: 0<        $8000 and ;
@

Not fitting in particularly well elsewhere, some mathematical operations are needed to make the machine language monitor work.  We start with determining the maximum or minimum value.</p>

<<Primitives>>=
: max       2dup - 0< if nip exit then drop ;
: min       2dup - 0< if drop exit then nip ;
@

<h2>100.20  Memory Accessors</h2>
@ Until now, we haven't addressed some of the more fundamental aspects of the J1 as it works with the Kestrel-2 hardware.  We start with the fetch operator, where we rely on software to extend the operation to two instruction cycles.  This provides the block RAMs on the Xilinx FPGA I'm using enough time to set up their address bus and deliver the data.  The J1, implementing an essentially asynchronous memory bus architecture, would work great as-is if we were talking to, say, a 62256 static RAM chip.  In this case, as soon as the address bus changes, the 62256 would take, say, 100ns to update its data bus.  Provided the J1 were clocked with a period at least as long as 100ns, the J1 could realize single-cycle read performance.  However, the RAMs used in the FPGA are <i>synchronous</i> RAMs, and are clocked off the processor clock for simplicity.  Therefore, as soon as the address bus changes, we need to wait at least one cycle for the block RAMs to catch up.</p>

<p>As it happens, a J1 subroutine call takes exactly one cycle.  We define [[@]] as a subroutine, consisting of precisely one instruction ([[@,]]), which both fetches and returns to the caller in a single cycle as well.  Thus, we achieve our desired two-cycle execution performance for [[@]].</p>

<<Primitives>>=
: @     @, ;

@ The J1 also requires, albeit for different reasons, two cycles to effect the [[!]] instruction.  The first instruction strobes the CPU's [[D_WE_O]] signal, telling the block RAMs to write the data instead of reading it, while the second cleans up the stack.  Best implemented as a macro, we find the definition for [[!]] in the assembler, [[asm.f]], rather than here.</p>

<p>The J1 can only access memory 16-bits at a time; accessing individual 8-bit quantities, important for character manipulation or some graphics operations, requires that we perform bit-field manipulations.  Applications should make every effort to minimize the use of character accessors, however, as these can incur significant program overheads.  [[c@]] consumes somewhere in the vicinity of 10 clock cycles, while [[c!]] consumes around 15.</p>

<<Primitives>>=
: c@        dup 1 and if @ 255 and exit then @ 8 rshift 255 and ;
: even!     swap 8 lshift over @ 255 and or swap ! ;
: odd!      swap 255 and over @ $FF00 and or swap ! ;
: c!        dup 1 and if odd! exit then even! ;

@ As you can see above, even addresses correspond to bits 15...8 of a word, while odd addresses correspond to bits 7...0.  This maintains consistency with how the video interface refreshes the display, and thus, how it expects bitmap data to be laid out in memory.</p>

@ While somewhat ambiguous with the category of mathematical procedure, [[+!]] proves useful for performing basic addition on a memory-resident variable without having to explicitly manage addresses.  Since it depends on [[@]] and [[!]] for its operation, we place its definition here.</p>

<<Primitives>>=
: +!            2dup @ + swap ! drop ;
@

<h2>B.3  Displaying Text</h2>

<p>The Kestrel-2 lacks a hardware character matrix display mode; instead, the video circuitry fetches bytes from memory starting at address [[$8000]] and displays them as a raw bitmap.  We cannot simply poke bytes into memory and expect fully-formed characters to appear on the screen.  The Kestrel-2 firmware provides a facility to emulate character matrix displays in software.  This results in a simpler hardware implementation and graphics when you need it, while incurring only modest software costs.</p>

<<Text Display Facility>>=
<<TDF global state>>

@ </p><h3>B.3.1  Character Font</h3>

<p>The 640&times;200 display resolution requires (640&div;16)&times;200=8 000 words of memory.  Using an 8&times;8 pixel font, that allows us to pack 80 columns by 25 rows of text on the screen.  The Kestrel-2 expects a single word of memory to hold two characters (or, put another way, one character consumes eight bits of storage), so (80&div;2)&times;25=1 000 words hold a complete character matrix.  This allows up to 256 characters to be represented by a single character matrix.</p>

<p>Displaying text requires we provide a number of small, 8&times;8 images, each representing some character on the screen.  Each image is known as a <i>glyph</i>.  The <i>font</i> contains the set of glyphs corresponding to each character.  The Kestrel-2 expects the font to exist as a 2 048&times;8 bitmap in memory, for 256 possible characters times 8 pixels per glyph row comes out to 2 048 total pixels.  Thus, the first 128 words (256 bytes) constitutes row 0 pixels for all 256 characters, the next 128 words row 1 pixels, and so on.  Arranging the font data this way allows a developer to use an image editing tool of his or her choice to create a font, then extract the raw bitmap data for direct use with the Kestrel-2.</p>

<p>The Kestrel-2 firmware references the font data via an ancillary Forth source file.
<<Text Display Facility>>=
<<TDF System Font>>

<<TDF System Font>>=
create font
include font.inc
@

<h3>B.3.2  Committing a Character Matrix</h3>

<p>In a perfect world, we would somehow convince the hardware to monitor some region of memory which we call the <i>character matrix</i> for updates.  Whenever we update memory in the matrix, the hardware would somehow recognize this event, and adjust the display accordingly.  As it happens, this is hard to do.  Not impossible, mind you.  There exists two ways to approach the problem&mdash;you could either poll memory at periodic intervals, which is what the video hardware already is designed to do, or you can maintain what's called a <q>write queue</q> to trap writes into the character matrix, where a processor on the other end of the queue discovers these writes and acts accordingly.  As you can imagine, the latter solution is the hardest approach to take of them all, and won't be discussed further here.  The former technique, widely used in such hardware platforms as the VGA-compatible chipsets and the Commodore 64's VIC-II chip, works by accessing memory <i>twice</i>; once to read the character, and once to grab the font data corresponding to that character.  I could have implemented this in the Kestrel-2's video circuitry, but since it roughly doubled the complexity of the hardware involved, I decided to just keep things as simple as possible, and stick with a pure bitmapped display interface.</p>

<p>The problem is, updating the bitmapped display takes eight times the effort than updating a simple character matrix.  Therefore, we want to minimize how often we actually push updates to the bitmapped display.  It's better to compute what we want the finished display to look like first, in the form of the character matrix, <i>then</i> perform a bulk update of the whole screen.  When we talk of <q>committing</q> a character matrix, we're talking about that final act of bulk-updating the bitmapped display.  The term comes from the field of transactions, where updates to a resource occurs when the transaction completes.</p>

<p>I implement a relatively slow algorithm below, but one which is known to work.  It takes the overall form:</p>
<<Text Display Facility>>=
<<TDF address computation logic>>
<<TDF commit glyph logic>>
<<TDF commit row logic>>
<<TDF commit screen-wide logic>>
<<TDF character matrix commit logic>>

@ We commit the display character by character, one glyph at a time, starting in the upper-lefthand corner of the display.  We know we need to update 25 rows of text.</p>

<<TDF character matrix commit logic>>=
: commit    0 x !  0 y !  25r ;

@ We address each character through the [[x]] and [[y]] state variables.  Note that these variables <i>do not</i> refer to any kind of cursor position; they're used only while committing the display, keeping track of which glyph we're painting into the bitmap.  They conform to the invariant that (0&le;<i>x</i>&lt;80)&and;(0&le;<i>y</i>&lt;25) while the screen update continues to proceed.</p>

<<TDF global state>>=
variable x
variable y

@ A screen consists of 25 rows, as established above.  If each execution of [[r]] bumps the [[y]] variable by one, then we can clearly see that upon completion of the operation, [[y]] will be set to 25.  While the update proceeds, we see that 0&le;<i>y</i>&lt;25, thus satisfying the invariant.</p>

<<TDF commit screen-wide logic>>=
: 8r        r r r r  r r r r ;
: 25r       8r 8r 8r r ;

@ Each row consists of 80 characters apiece.  As each row completes, we make sure to reset our (x,y) coordinates to keep track of where the next row begins.  During the update of a single row, 0&le;<i>x</i>&le;80.  However, because [[r]] resets the [[x]] variable back to zero upon finishing each row, and because we know that 0&le;<i>y</i>&lt;25 while the commit progresses, the global invariants hold.</p>

<<TDF commit row logic>>=
: 10c       c c c c c  c c c c c ;
: 80c       10c 10c 10c 10c  10c 10c 10c 10c ;
: r         80c  0 x ! 1 y @ + y ! ;

@ We draw each character by cycling through all eight raster lines of its shape, copying data from the font data to the bitmap along the way.  After we're done copying the glyph, we update our (x,y) state to prepare for the next character to be copied.</p>

<<TDF commit glyph logic>>=
: s         chradr c@ glyph c@ bmadr c!  1 raster @ + raster ! ;
: c         0 raster !  s s s s  s s s s  1 x @ + x ! ;

@ When updating the bitmap, we need to know which character to draw.  We address a character in the character matrix based on the current (valid) values of the [[x]] and [[y]] variables.  The equation to compute an address for any character in the matrix is <i>a</i> = <i>character_matrix_base</i> + <i>x</i> + 80<i>y</i>.</p>

<<TDF address computation logic>>=
: chradr    y @ 80* x @ + TdfChrMtx @ + ;

<<TDF global state>>=
variable TdfChrMtx

@ The TDF user must initialize the [[TdfChrMtx]] variable prior to invoking [[commit]], lest garbage be rendered on the screen.  Further, make sure the 1 000 cells referenced by [[TdfChrMtx]] never overlaps read-triggered I/O space, as the screen update will fire the I/O triggers.</p>

<b>ISSUE: we need a better name for [[TdfChrMtx]].</b>

<p>Next, we need to resolve which row of the glyph's picture to use.  We calculate the glyph's bitmap byte address using the character code (on the data stack) and knowledge of which [[raster]] we're drawing.  Its formula is, <i>a</i> = <i>font_base</i> + <i>c</i> + 256<i>s</i>, where 0&le;<i>c</i>&lt;256 contains the character code, and 0&le;<i>s</i>&lt;8 contains the current raster scanline.

<<TDF address computation logic>>=
: glyph     font + raster @ 256* + ;

<<TDF global state>>=
variable raster

@ Finally, we just place the glyph image data in the destination bitmap.  The correct row of pixels in the target bitmap is computed using a formula similar to that used to determine the character matrix byte address, but adjusted to compensate for the bitmapped nature: <i>a</i> = <i>bitmap_base</i> + <i>x</i> + 80<i>s</i> + 640<i>y</i>, where 0&le;<i>s</i>&lt;8 refers to the specific scanline of the glyph.  Remember, we defined the system font height as eight.</p>

<<TDF address computation logic>>=
: bmadr     y @ 640* raster @ 80* + x @ + $8000 + ;

@ </p><h3>B.3.3  Miscellaneous</h3>

@ You might have noticed a few multiplications going on, expressed as single words instead of separate calls to [[*]].  The J1, not being a terribly sophisticated processor, lacks hardware multiplication support.  This means that we'd need to implement [[*]], a non-trivial task, if we wanted to perform general purpose multiplication.  As it happens, we always multiply by a constant factor, which allows us to create words which computes the desired results using <i>shifts and additions</i> instead.  This also has the benefit of isolating the Text Display Facility from the rest of the system firmware, useful for debugging purposes.</p>

<<Primitives>>=
: 8*        3 lshift ;
: 16*       4 lshift ;
: 80*       4 lshift dup 2 lshift + ;
: 256*      8 lshift ;
: 640*      80* 8* ;

@ </p><h3>B.3.4  Example</h3>

<p>First, we create our character matrix.  To be safe, we'll allot 2KiB of memory to the character matrix, but we'll only use 2KB.</p>

<<TDF Example Code>>=
create myChrmtx
    2048 allot

@ Next, we'll populate our character matrix with all 256 characters, arranged as a 16&times;16 matrix of characters, along the left-edge of the screen.  The right-hand side will be blank.  However, this populates only 16 of the 25 rows on the screen, so we'll fill the nine remaining rows with dots.</p>

<<TDF Example Code>>=
: c         over over c!  1 + swap 1 + swap ;
: 16cols    c c c c  c c c c  c c c c  c c c c ;
: s         32 over c!  1 + ;
: 16s       s s s s  s s s s  s s s s  s s s s ;
: 64spcs    16s 16s 16s 16s ;
: r         16cols  64spcs ;
: 16rows    r r r r  r r r r  r r r r  r r r r ;
: d         $2E over c!  1 + ;
: 10d       d d d d d  d d d d d ;
: r         10d 10d 10d 10d  10d 10d 10d 10d ;
: 9rows     r r r r  r r r r  r ;
: chrmtx0   0 myChrmtx 16rows 9rows 2drop ;

@ As our main program, we'll initialize the character matrix with the above code, configure [[TdfChrMtx]] to point to our matrix, and commit the display.  We'll then busy-wait forever, so that the user can see the results.</p>

<<TDF Example Code>>=
: halt      $8100 @ invert $8100 !  recurse ;
: main      chrmtx0  myChrmtx TdfChrMtx !  commit  halt ;

@
</body>
