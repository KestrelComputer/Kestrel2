<div class="blogArticleTitle">
 Preen Release 1A: a Kestrel-2 Monitor
</div>
<div class="blogArticleTimestampAuthor">
 <div class="blogArticleAuthor">Samuel A. Falvo II<br>kc5tja -at- arrl.net</div>
 <div class="blogArticleTimestamp">2011 Aug 27 17:34 PDT</div>
</div>
<div class="blogArticleLead">
 <p>
  Bringing up a new computer from scratch poses a chicken-and-egg problem.  When the system software under development unexpectedly fails, no extant means exists to determine hardware or software culpability.  A reference program written to run under both an emulator and physical hardware can help isolate causes of failure.  Software which fails on physical hardware but not in an emulated environment justifies further investment in debugging the hardware.
 </p>
 <p>
  Ideally, the reference program should exercise, at a minimum, all peripherals required to support an interactive user experience.  A personal computer without a user interface serves no useful purpose.  A simple monitor program provides a means to exercise a video display output, keyboard input, and some more esoteric properties of the host CPU.  Further, a monitor may provide a useful debugging aid for diagnosing problems when higher-level software or hardware components fail.
 </p>
</div>
<div class="blogArticleBody">

<h1>10  Binary Image Generation</h1>
@ Each ROM image source file is a regular Forth script.  We start Forth using something like <q>gforth [[preen.f]]</q>, and rely on the implementation of [[preen.f]] to do the right thing.  Since we're going to be assembling code for the target processor, we need to load the assembler into the host's dictionary.</p>

<<Load target development>>=
include asm.f
@

When loaded, the assembler's internal data structures will be in an unknown state.  We need to reset the assembler state.</p>

<<Load target development>>=
0symtab
@

The J1 processor begins its execution at address zero in its memory map.  Since the assembler doesn't yet know what code we're going to place further on in memory, we're going to compile a forward jump.  The [[DEFER]] keyword is the best way I know how to achieve this.  Later, when we're done assembling, we can patch up this vector with the proper entry point address.</p>

<<Origin directive>>=
0 org
<<Reset vector>>=
defer _main
@ %def _main
<<Patch reset vector>>=
' breakpoint is _main
@

Once everything's been assembled, we create the ROM file on the host computer, and terminate the Forth session.</p>

<<Emit binary file>>=
host romfile  bye
@

All other sections refer to target-specific code, so let's make sure we configure the Forth environment to produce software in the target.</p>

<<Origin directive>>=
target
@

In summary, the top-level layout of the program follows:</p>

<<preen.f>>=
<<Load target development>>
<<Origin directive>>
<<Reset vector>>
<<Primitives>>

<<System software state>>
<<Screen Editor>>
<<Breakpoint handler>>

<<Text Display Facility>>
<<TDF Example Code>>
<<Patch reset vector>>
<<Emit binary file>>
@

<h1>20  Breakpoints</h1>
@ The J1 processor as used in the Kestrel-2 lacks interrupts; therefore, the processor cannot reasonably respond to such things as illegal memory accesses or malformed instructions.  Control transfers to the monitor, like all other software on the J1 processor, through explicit control flow instructions.  In this case, applications invoke a <i>breakpoint</i>.</p>

@ A breakpoint behaves like a software-defined interrupt.  The application containing a breakpoint instruction <i>trusts</i> the processor state will remain unaltered before and afterwards.  (Of course, the user has the option of altering the state of the running program.)  In order to display the machine state to the user, it must be preserved in memory somewhere, so we'll need some storage space.</p>

<<System software state>>=
: dstack        $4000 ;
: rstack        dstack 64 + ;
@ %def dstack rstack

You'll notice that no space exists for the program counter.  Since the breakpoint handler will be invoked via a [[CALL]] instruction, it already exists at the top of the return stack.  <i>Note that this implies that only 31 return stack elements are preserved by the breakpoint handler.</i>  Therefore, Preen will likely cause any program which depends on the availability of all 32 return stack registers to crash.</p>

@ The J1 provides the programmer with <i>33</i> data stack registers.  These include [[T]], the top of the stack which feeds the J1's first ALU input, and 32 other stack registers.  However, in the state above, we reserve only 32 slots.  Since the J1 lacks an instruction to store its state in a memory location, we need to use [[!]] to store to memory the state of the data stack.  Pushing the address that [[!]] will store to necessarily causes the 33rd stack cell to disappear, <i>thus leaving only 32 of the 33 data stack items available for inspection.</i>  Preen will likely cause any program which depends on the availability of all 33 data stack registers to crash.</p>

@ When the breakpoint hits, Preen must assume the program uses all data and return stack items.  Therefore, the breakpoint handler must free up enough stack space to function.  First we free up a handful of data stack items, which will in turn enable us to free up a few return stack slots.  Once complete, we can start using higher-level Forth definitions again.  Note we avoid invoking [[dstack]] and [[rstack]] because we don't want to disturb the state of the return stack just yet.</p>

<<Breakpoint handler>>=
<<ds!>>
<<rs!>>
: breakpoint
  $4000 !  $4002 !  $4004 !  $4006 !
  r> $4040 !  r> $4042 !  r> $4044 !  r> $4046 !
@ %def breakpoint

Now that we have some play in the two stacks, we can rely on higher-level definitions to save the processor state without having to explicitly list all the memory addresses by hand.</p>

<<Breakpoint handler>>=
  dstack 8 + ds!  rstack 8 + rs!
@

[[ds!]] will store 28 cells of the interrupted program's data stack.  Remember that [[breakpoint]] already stored four data stack items manually at the start of its definition, bringing the total number of data stack items saved to 32.</p>

<p>
<<ds!>>=
: c         2dup ! 2 + nip ;
: 7c        c c c c c c c ;
: ds!       7c 7c 7c 7c drop ;
@ %def ds!

Committing the data stack to memory frees up the data stack &mdash; the monitor may now utilize all 32 cells if it wishes.  We still need to preserve the return stack, however.  We need a somewhat different strategy for the return stack, because invoking [[rs!]] itself uses the return stack.</p>

<<rs!>>=
: rs!       r> swap <<write 28 cells>> drop >r ;
@ %def rs!

Regrettably, we cannot rely on subroutine calls while we're manipulating the return stack, so we need to inline 28 cell stores directly.</p>

<<write 28 cells>>=
<<write 7 cells>>
<<write 7 cells>>
<<write 7 cells>>
<<write 7 cells>>
@

<<write 7 cells>>=
<<write a cell>>
<<write a cell>>
<<write a cell>>
<<write a cell>>
<<write a cell>>
<<write a cell>>
<<write a cell>>
@

<<write a cell>>=
r> over ! 2 +
@

Once both the data and return stacks have been committed to memory, the entire state of the interrupted program avails itself for inspection.  Recall that the interrupted program's instruction pointer resides in the cell at [[rstack]]+0.  This leaves [[breakpoint]] with only one last task to perform: kick off the monitor's user interface.</p>

<<Breakpoint handler>>=
  ui ;
@ </p>

<h1>30  Displaying the Program State</h1>

@ Before the user can interact with the debugger, the user needs to see what the program's state is.</p>

<h1>40  Screen Editor Interface</h1>

@ The text cursor resides somewhere on the character matrix.  These variables record where.  Note that many address calculations depend on the values of [[x]] and [[y]], so we require the invariants 0&le;[[x]]&lt;80 &and; 0&le;[[y]]&lt;25, lest some part of the screen editor ends up corrupting memory.</p>

<<Screen Editor>>=
variable x
variable y
@

We calculate the bitmap address of the glyph under the cursor by considering the cursor's current values.</p>

<<Screen Editor>>=
: address       y @ 640* x @ + $8000 + ;
@

We implement the text cursor by reversing the video of a given character glyph in the bitmap.</p>

<<Screen Editor>>=
: b             dup dup c@ invert swap c! 80 + ;
: blink         address b b b b b b b b drop ;
@

The Kestrel-2 runs its J1 processor at 12.5MHz more or less, so if we want the cursor to blink with a period of a quarter second, we need to wait close to (12.5&div;4)=3.125 million cycles between each blink state change.  Since a typical delay loop looks like this,</p>

<<Screen Editor>>=
: wait1         1 + dup if recurse exit then ;
@

we know each loop iteration takes five cycles to complete, except for the last which takes six.  If we pass zero as a parameter to [[wait1]], it will stall for 65536 complete loop iterations, or 5&times;65535+6=327 681 machine cycles.  Getting close to our desired blink rate requires we invoke such a loop 3 125 000&div;327 681=9 (approx.) times.</p>

<<Screen Editor>>=
: wait0         0 wait1 drop  $FFFF + dup if recurse exit then ;
: wait          9 wait0 drop ;
@

This is a temporary definition for [[ui]].  Eventually, we want this to be the main loop for the monitor.</p>

<<Screen Editor>>=
: +!            2dup @ + swap ! drop ;
: ui            blink wait blink wait 1 x +! recurse ;
@ </p>

<h1>100  Memory Access Primitives</h1>
@ Until now, we haven't addressed some of the more fundamental aspects of the J1 as it works with the Kestrel-2 hardware.  We start with the fetch operator, where we rely on software to extend the operation to two instruction cycles.  This provides the block RAMs on the Xilinx FPGA I'm using enough time to set up their address bus and deliver the data.  The J1, implementing an essentially asynchronous memory bus architecture, would work great as-is if we were talking to, say, a 62256 static RAM chip.  In this case, as soon as the address bus changes, the 62256 would take, say, 100ns to update its data bus.  Provided the J1 were clocked with a period at least as long as 100ns, the J1 could realize single-cycle read performance.  However, the RAMs used in the FPGA are <i>synchronous</i> RAMs, and are clocked off the processor clock for simplicity.  Therefore, as soon as the address bus changes, we need to wait at least one cycle for the block RAMs to catch up.</p>

<p>As it happens, a J1 subroutine call takes exactly one cycle.  We define [[@]] as a subroutine, consisting of precisely one instruction ([[@,]]), which both fetches and returns to the caller in a single cycle as well.  Thus, we achieve our desired two-cycle execution performance for [[@]].</p>

<<Primitives>>=
: @     @, ;

@ The J1 also requires, albeit for different reasons, two cycles to effect the [[!]] instruction.  The first instruction strobes the CPU's [[D_WE_O]] signal, telling the block RAMs to write the data instead of reading it, while the second cleans up the stack.  Best implemented as a macro, we find the definition for [[!]] in the assembler, [[asm.f]], rather than here.</p>

<p>The J1 can only access memory 16-bits at a time; accessing individual 8-bit quantities, important for character manipulation or some graphics operations, requires that we perform bit-field manipulations.  Applications should make every effort to minimize the use of character accessors, however, as these can incur significant program overheads.  [[c@]] consumes somewhere in the vicinity of 10 clock cycles, while [[c!]] consumes around 15.</p>

<<Primitives>>=
: c@        dup 1 and if @ 255 and exit then @ 8 rshift 255 and ;
: even!     swap 8 lshift over @ 255 and or swap ! ;
: odd!      swap 255 and over @ $FF00 and or swap ! ;
: c!        dup 1 and if odd! exit then even! ;

@ As you can see above, even addresses correspond to bits 15...8 of a word, while odd addresses correspond to bits 7...0.  This maintains consistency with how the video interface refreshes the display, and thus, how it expects bitmap data to be laid out in memory.</p>

<h2>B.3  Displaying Text</h2>

<p>The Kestrel-2 lacks a hardware character matrix display mode; instead, the video circuitry fetches bytes from memory starting at address [[$8000]] and displays them as a raw bitmap.  We cannot simply poke bytes into memory and expect fully-formed characters to appear on the screen.  The Kestrel-2 firmware provides a facility to emulate character matrix displays in software.  This results in a simpler hardware implementation and graphics when you need it, while incurring only modest software costs.</p>

<<Text Display Facility>>=
<<TDF global state>>

@ </p><h3>B.3.1  Character Font</h3>

<p>The 640&times;200 display resolution requires (640&div;16)&times;200=8 000 words of memory.  Using an 8&times;8 pixel font, that allows us to pack 80 columns by 25 rows of text on the screen.  The Kestrel-2 expects a single word of memory to hold two characters (or, put another way, one character consumes eight bits of storage), so (80&div;2)&times;25=1 000 words hold a complete character matrix.  This allows up to 256 characters to be represented by a single character matrix.</p>

<p>Displaying text requires we provide a number of small, 8&times;8 images, each representing some character on the screen.  Each image is known as a <i>glyph</i>.  The <i>font</i> contains the set of glyphs corresponding to each character.  The Kestrel-2 expects the font to exist as a 2 048&times;8 bitmap in memory, for 256 possible characters times 8 pixels per glyph row comes out to 2 048 total pixels.  Thus, the first 128 words (256 bytes) constitutes row 0 pixels for all 256 characters, the next 128 words row 1 pixels, and so on.  Arranging the font data this way allows a developer to use an image editing tool of his or her choice to create a font, then extract the raw bitmap data for direct use with the Kestrel-2.</p>

<p>The Kestrel-2 firmware references the font data via an ancillary Forth source file.
<<Text Display Facility>>=
<<TDF System Font>>

<<TDF System Font>>=
create font
include font.inc
@

<h3>B.3.2  Committing a Character Matrix</h3>

<p>In a perfect world, we would somehow convince the hardware to monitor some region of memory which we call the <i>character matrix</i> for updates.  Whenever we update memory in the matrix, the hardware would somehow recognize this event, and adjust the display accordingly.  As it happens, this is hard to do.  Not impossible, mind you.  There exists two ways to approach the problem&mdash;you could either poll memory at periodic intervals, which is what the video hardware already is designed to do, or you can maintain what's called a <q>write queue</q> to trap writes into the character matrix, where a processor on the other end of the queue discovers these writes and acts accordingly.  As you can imagine, the latter solution is the hardest approach to take of them all, and won't be discussed further here.  The former technique, widely used in such hardware platforms as the VGA-compatible chipsets and the Commodore 64's VIC-II chip, works by accessing memory <i>twice</i>; once to read the character, and once to grab the font data corresponding to that character.  I could have implemented this in the Kestrel-2's video circuitry, but since it roughly doubled the complexity of the hardware involved, I decided to just keep things as simple as possible, and stick with a pure bitmapped display interface.</p>

<p>The problem is, updating the bitmapped display takes eight times the effort than updating a simple character matrix.  Therefore, we want to minimize how often we actually push updates to the bitmapped display.  It's better to compute what we want the finished display to look like first, in the form of the character matrix, <i>then</i> perform a bulk update of the whole screen.  When we talk of <q>committing</q> a character matrix, we're talking about that final act of bulk-updating the bitmapped display.  The term comes from the field of transactions, where updates to a resource occurs when the transaction completes.</p>

<p>I implement a relatively slow algorithm below, but one which is known to work.  It takes the overall form:</p>
<<Text Display Facility>>=
<<TDF address computation logic>>
<<TDF commit glyph logic>>
<<TDF commit row logic>>
<<TDF commit screen-wide logic>>
<<TDF character matrix commit logic>>

@ We commit the display character by character, one glyph at a time, starting in the upper-lefthand corner of the display.  We know we need to update 25 rows of text.</p>

<<TDF character matrix commit logic>>=
: commit    0 x !  0 y !  25r ;

@ We address each character through the [[x]] and [[y]] state variables.  Note that these variables <i>do not</i> refer to any kind of cursor position; they're used only while committing the display, keeping track of which glyph we're painting into the bitmap.  They conform to the invariant that (0&le;<i>x</i>&lt;80)&and;(0&le;<i>y</i>&lt;25) while the screen update continues to proceed.</p>

<<TDF global state>>=
variable x
variable y

@ A screen consists of 25 rows, as established above.  If each execution of [[r]] bumps the [[y]] variable by one, then we can clearly see that upon completion of the operation, [[y]] will be set to 25.  While the update proceeds, we see that 0&le;<i>y</i>&lt;25, thus satisfying the invariant.</p>

<<TDF commit screen-wide logic>>=
: 8r        r r r r  r r r r ;
: 25r       8r 8r 8r r ;

@ Each row consists of 80 characters apiece.  As each row completes, we make sure to reset our (x,y) coordinates to keep track of where the next row begins.  During the update of a single row, 0&le;<i>x</i>&le;80.  However, because [[r]] resets the [[x]] variable back to zero upon finishing each row, and because we know that 0&le;<i>y</i>&lt;25 while the commit progresses, the global invariants hold.</p>

<<TDF commit row logic>>=
: 10c       c c c c c  c c c c c ;
: 80c       10c 10c 10c 10c  10c 10c 10c 10c ;
: r         80c  0 x ! 1 y @ + y ! ;

@ We draw each character by cycling through all eight raster lines of its shape, copying data from the font data to the bitmap along the way.  After we're done copying the glyph, we update our (x,y) state to prepare for the next character to be copied.</p>

<<TDF commit glyph logic>>=
: s         chradr c@ glyph c@ bmadr c!  1 raster @ + raster ! ;
: c         0 raster !  s s s s  s s s s  1 x @ + x ! ;

@ When updating the bitmap, we need to know which character to draw.  We address a character in the character matrix based on the current (valid) values of the [[x]] and [[y]] variables.  The equation to compute an address for any character in the matrix is <i>a</i> = <i>character_matrix_base</i> + <i>x</i> + 80<i>y</i>.</p>

<<TDF address computation logic>>=
: chradr    y @ 80* x @ + TdfChrMtx @ + ;

<<TDF global state>>=
variable TdfChrMtx

@ The TDF user must initialize the [[TdfChrMtx]] variable prior to invoking [[commit]], lest garbage be rendered on the screen.  Further, make sure the 1 000 cells referenced by [[TdfChrMtx]] never overlaps read-triggered I/O space, as the screen update will fire the I/O triggers.</p>

<b>ISSUE: we need a better name for [[TdfChrMtx]].</b>

<p>Next, we need to resolve which row of the glyph's picture to use.  We calculate the glyph's bitmap byte address using the character code (on the data stack) and knowledge of which [[raster]] we're drawing.  Its formula is, <i>a</i> = <i>font_base</i> + <i>c</i> + 256<i>s</i>, where 0&le;<i>c</i>&lt;256 contains the character code, and 0&le;<i>s</i>&lt;8 contains the current raster scanline.

<<TDF address computation logic>>=
: glyph     font + raster @ 256* + ;

<<TDF global state>>=
variable raster

@ Finally, we just place the glyph image data in the destination bitmap.  The correct row of pixels in the target bitmap is computed using a formula similar to that used to determine the character matrix byte address, but adjusted to compensate for the bitmapped nature: <i>a</i> = <i>bitmap_base</i> + <i>x</i> + 80<i>s</i> + 640<i>y</i>, where 0&le;<i>s</i>&lt;8 refers to the specific scanline of the glyph.  Remember, we defined the system font height as eight.</p>

<<TDF address computation logic>>=
: bmadr     y @ 640* raster @ 80* + x @ + $8000 + ;

@ </p><h3>B.3.3  Miscellaneous</h3>

@ You might have noticed a few multiplications going on, expressed as single words instead of separate calls to [[*]].  The J1, not being a terribly sophisticated processor, lacks hardware multiplication support.  This means that we'd need to implement [[*]], a non-trivial task, if we wanted to perform general purpose multiplication.  As it happens, we always multiply by a constant factor, which allows us to create words which computes the desired results using <i>shifts and additions</i> instead.  This also has the benefit of isolating the Text Display Facility from the rest of the system firmware, useful for debugging purposes.</p>

<<Primitives>>=
: 8*        3 lshift ;
: 16*       4 lshift ;
: 80*       4 lshift dup 2 lshift + ;
: 256*      8 lshift ;
: 640*      80* 8* ;

@ </p><h3>B.3.4  Example</h3>

<p>First, we create our character matrix.  To be safe, we'll allot 2KiB of memory to the character matrix, but we'll only use 2KB.</p>

<<TDF Example Code>>=
create myChrmtx
    2048 allot

@ Next, we'll populate our character matrix with all 256 characters, arranged as a 16&times;16 matrix of characters, along the left-edge of the screen.  The right-hand side will be blank.  However, this populates only 16 of the 25 rows on the screen, so we'll fill the nine remaining rows with dots.</p>

<<TDF Example Code>>=
: c         over over c!  1 + swap 1 + swap ;
: 16cols    c c c c  c c c c  c c c c  c c c c ;
: s         32 over c!  1 + ;
: 16s       s s s s  s s s s  s s s s  s s s s ;
: 64spcs    16s 16s 16s 16s ;
: r         16cols  64spcs ;
: 16rows    r r r r  r r r r  r r r r  r r r r ;
: d         $2E over c!  1 + ;
: 10d       d d d d d  d d d d d ;
: r         10d 10d 10d 10d  10d 10d 10d 10d ;
: 9rows     r r r r  r r r r  r ;
: chrmtx0   0 myChrmtx 16rows 9rows 2drop ;

@ As our main program, we'll initialize the character matrix with the above code, configure [[TdfChrMtx]] to point to our matrix, and commit the display.  We'll then busy-wait forever, so that the user can see the results.</p>

<<TDF Example Code>>=
: halt      $8100 @ invert $8100 !  recurse ;
: main      chrmtx0  myChrmtx TdfChrMtx !  commit  halt ;

@
</body>
