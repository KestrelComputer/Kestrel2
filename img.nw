<h1>B.  Kestrel-2 ROM Image</h1>

@ The top-level layout of the image file follows:</p>

<<img.f>>=
<<Load target development>>
<<Origin directive>>
<<Reset vector>>
<<Primitives>>
<<Text Display Facility>>
<<undocumented>>
<<Patch reset vector>>
<<Emit binary file>>

@
<h2>B.1  Using the Target Assembler</h2>

@ Each ROM image source file is a regular Forth script.  We start Forth using something like <q>gforth [[img.f]]</q>, and rely on the implementation of [[img.f]] to do the right thing.  Since we're going to be assembling code for the target processor, we need to load the assembler into the host's dictionary.</p>

<<Load target development>>=
include asm.f

@ When loaded, the assembler's internal data structures will be in an unknown state.  We need to reset the assembler state.</p>

<<Load target development>>=
0symtab

@ The J1 processor begins its execution at address zero in its memory map.  Since the assembler doesn't yet know what code we're going to place further on in memory, we're going to compile a forward jump.  The [[DEFER]] keyword is the best way I know how to achieve this.  Later, when we're done assembling, we can patch up this vector with the proper entry point address.</p>

<<Origin directive>>=
0 org

<<Reset vector>>=
defer _main

<<Patch reset vector>>=
' main is _main

@ Once everything's been assembled, we create the ROM file on the host computer, and terminate the Forth session.</p>

<<Emit binary file>>=
host romfile  bye

@ All other sections refer to target-specific code, so let's make sure we configure the Forth environment to produce software in the target.</p>

<<Origin directive>>=
target

@
<h2>B.2  J1 Quirks</h2>

@ The J1, at least as used in the Kestrel-2, has a few quirks that the system programmer needs to be aware of.  We start with the fetch operator, where we rely on software to extend the operation to two instruction cycles.  This provides the block RAMs on the Xilinx FPGAs I'm using enough time to set up their address bus and deliver the data.  The J1, implementing an asynchronous memory bus architecture, would work great as-is if we were talking to, say, a 62256 static RAM chip.  In this case, as soon as the address bus changes, the 62256 would take, say, 100ns to update its data bus.  Provided the J1 were clocked with a period at least as long as 100ns, the J1 could realize single-cycle read performance.  However, the RAMs used in the FPGA are <i>synchronous</i> RAMs, and are clocked off the processor clock for simplicity.  Therefore, as soon as the address bus changes, we need to wait at least one cycle for the block RAMs to catch up.</p>

<p>As it happens, a J1 subroutine call takes exactly one cycle.  We define [[@]] as a subroutine, consisting of precisely one instruction ([[@,]]), which both fetches and returns to the caller in a single cycle as well.  Thus, we achieve our desired two-cycle execution performance for [[@]].</p>

<<Primitives>>=
: @     @, ;

@ The J1 also requires, albeit for different reasons, two cycles to effect the [[!]] instruction.  The first instruction strobes the CPU's [[D_WE_O]] signal, telling the block RAMs to write the data instead of reading it, while the second cleans up the stack.  Best implemented as a macro, we find the definition for [[!]] in the assembler, [[asm.f]], rather than here.</p>

<p>The J1 can only access memory 16-bits at a time; accessing individual 8-bit quantities, important for character manipulation or some graphics operations, requires that we perform bit-field manipulations.  Applications should make every effort to minimize the use of character accessors, however, as these can incur significant program overheads.  [[c@]] consumes somewhere in the vicinity of 10 clock cycles, while [[c!]] consumes around 15.</p>

<<Primitives>>=
: c@        dup 1 and if @ 255 and exit then @ 8 rshift 255 and ;
: even!     swap 8 lshift over @ 255 and or swap ! ;
: odd!      swap 255 and over @ $FF00 and or swap ! ;
: c!        dup 1 and if odd! exit then even! ;

@ As you can see above, even addresses correspond to bits 15&hellip;8 of a word, while odd addresses correspond to bits 7&hellip;0.  This maintains consistency with how the video interface refreshes the display, and thus, how it expects bitmap data to be laid out in memory.</p>

<h2>B.3  Displaying Text</h2>

<p>The Kestrel-2 lacks a hardware character matrix display mode; instead, the video circuitry fetches bytes from memory starting at address [[$8000]] and displays them as a raw bitmap.  We cannot simply poke bytes into memory and expect fully-formed characters to appear on the screen.  The Kestrel-2 firmware provides a facility to emulate character matrix displays in software.  This results in a simpler hardware implementation and graphics when you need it, while incurring only modest software costs.</p>

<p>The 640&times;200 display resolution requires (640&div;16)&times;200=8 000 words of memory.  Using an 8&times;8 pixel font, that allows us to pack 80 columns by 25 rows of text on the screen.  The Kestrel-2 expects a single word of memory to hold two characters, so (80&div;2)&times;25=1 000 words hold a complete character matrix.  Software maintains this character matrix just like it would if the video display hardware had a native character matrix mode.  Only one difference exists between a hardware character matrix and software character matrix implementation: the software must remember to <q>commit</q> its changes to the screen when it's finished updating the screen.</p>

<<Text Display Facility>>=
<<System Font>>
@ </p>

<h3>B.3.1  Character Font</h3>

<p>Displaying text requires we provide a number of small, 8&times;8 images, each representing some character on the screen.  Eight bits constitutes a character code, thus letting us represent up to 256 characters in a single character matrix.  The Kestrel-2 expects the font to exist as a 2 048&times;8 bitmap in memory, for 8&times;256=2 048.  Thus, the first 128 words constitutes row 0 pixels for all 256 characters, the next 128 words row 1 pixels, and so on.  Arranging the font data this way allows a developer to use an image editing tool of his or her choice to create a font, then extract the raw bitmap data for direct use with the Kestrel-2.</p>

<p>The Kestrel-2 firmware references the font data via an ancillary Forth source file.
<<System Font>>=
create font
include font.inc
@

<h3>B.3.2  Committing a Character Matrix</h3>

<<undocumented>>=
create chrmtx
    2048 allot

: c         over over c!  1 + swap 1 + swap ;
: 16cols    c c c c  c c c c  c c c c  c c c c ;
: s         32 over c!  1 + ;
: 16s       s s s s  s s s s  s s s s  s s s s ;
: 64spcs    16s 16s 16s 16s ;
: r         16cols  64spcs ;
: 16rows    r r r r  r r r r  r r r r  r r r r ;
: d         $2E over c!  1 + ;
: 10d       d d d d d  d d d d d ;
: r         10d 10d 10d 10d  10d 10d 10d 10d ;
: 9rows     r r r r  r r r r  r ;
: chrmtx0   0 chrmtx 16rows 9rows 2drop ;

variable x
variable y
variable raster

: 8*        3 lshift ;
: 16*       4 lshift ;
: 80*       4 lshift dup 2 lshift + ;
: 256*      8 lshift ;
: 640*      80* 8* ;
: bmadr     y @ 640* raster @ 80* + x @ + $8000 + ;
: glyph     font + raster @ 256* + ;
: chradr    y @ 80* x @ + chrmtx + ;
: s         chradr c@ glyph c@ bmadr c!  1 raster @ + raster ! ;
: c         0 raster !  s s s s  s s s s  1 x @ + x ! ;
: 10c       c c c c c  c c c c c ;
: r         10c 10c 10c 10c  10c 10c 10c 10c  0 x ! 1 y @ + y ! ;
: 8r        r r r r  r r r r ;
: 25r       8r 8r 8r r ;
: commit    0 x !  0 y !  25r ;
: halt      $8100 @ invert $8100 !  recurse ;
: main      chrmtx0 commit halt ;

: -1        $FFFF ;
: cyc       dup if -1 + recurse exit then drop ;
: 64kcyc    dup if -1 + $FFFF cyc recurse exit then drop ;
: 1sec      8 64kcyc ;
: c@        dup 1 and if @ 255 and exit then @ 8 rshift 255 and ;
: even!     swap 8 lshift over @ 255 and or swap ! ;
: odd!      swap 255 and over @ $FF00 and or swap ! ;
: c!        dup 1 and if odd! exit then even! ;
: r         over c@ over c! 80 + swap 256 + swap ;
: plch      font + $8000 r r r r r r r r 2drop ;
: pl        plch 1sec ;
: chrs      dup 256 xor if dup pl 1 + recurse exit then drop ;
: ___main      35 chrs recurse ;

