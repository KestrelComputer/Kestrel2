<h1>B.  Kestrel-2 ROM Image</h1>

@ The top-level layout of the image file follows:</p>

<<img.f>>=
<<Load target development>>
<<Origin directive>>
<<Reset vector>>
<<Primitives>>
<<Text Display Facility>>
<<TDF Example Code>>
<<Patch reset vector>>
<<Emit binary file>>

@
<h2>B.1  Using the Target Assembler</h2>

@ Each ROM image source file is a regular Forth script.  We start Forth using something like <q>gforth [[img.f]]</q>, and rely on the implementation of [[img.f]] to do the right thing.  Since we're going to be assembling code for the target processor, we need to load the assembler into the host's dictionary.</p>

<<Load target development>>=
include asm.f

@ When loaded, the assembler's internal data structures will be in an unknown state.  We need to reset the assembler state.</p>

<<Load target development>>=
0symtab

@ The J1 processor begins its execution at address zero in its memory map.  Since the assembler doesn't yet know what code we're going to place further on in memory, we're going to compile a forward jump.  The [[DEFER]] keyword is the best way I know how to achieve this.  Later, when we're done assembling, we can patch up this vector with the proper entry point address.</p>

<<Origin directive>>=
0 org

<<Reset vector>>=
defer _main

<<Patch reset vector>>=
' main is _main

@ Once everything's been assembled, we create the ROM file on the host computer, and terminate the Forth session.</p>

<<Emit binary file>>=
host romfile  bye

@ All other sections refer to target-specific code, so let's make sure we configure the Forth environment to produce software in the target.</p>

<<Origin directive>>=
target

@
<h2>B.2  J1 Quirks</h2>

@ The J1, at least as used in the Kestrel-2, has a few quirks that the system programmer needs to be aware of.  We start with the fetch operator, where we rely on software to extend the operation to two instruction cycles.  This provides the block RAMs on the Xilinx FPGAs I'm using enough time to set up their address bus and deliver the data.  The J1, implementing an asynchronous memory bus architecture, would work great as-is if we were talking to, say, a 62256 static RAM chip.  In this case, as soon as the address bus changes, the 62256 would take, say, 100ns to update its data bus.  Provided the J1 were clocked with a period at least as long as 100ns, the J1 could realize single-cycle read performance.  However, the RAMs used in the FPGA are <i>synchronous</i> RAMs, and are clocked off the processor clock for simplicity.  Therefore, as soon as the address bus changes, we need to wait at least one cycle for the block RAMs to catch up.</p>

<p>As it happens, a J1 subroutine call takes exactly one cycle.  We define [[@]] as a subroutine, consisting of precisely one instruction ([[@,]]), which both fetches and returns to the caller in a single cycle as well.  Thus, we achieve our desired two-cycle execution performance for [[@]].</p>

<<Primitives>>=
: @     @, ;

@ The J1 also requires, albeit for different reasons, two cycles to effect the [[!]] instruction.  The first instruction strobes the CPU's [[D_WE_O]] signal, telling the block RAMs to write the data instead of reading it, while the second cleans up the stack.  Best implemented as a macro, we find the definition for [[!]] in the assembler, [[asm.f]], rather than here.</p>

<p>The J1 can only access memory 16-bits at a time; accessing individual 8-bit quantities, important for character manipulation or some graphics operations, requires that we perform bit-field manipulations.  Applications should make every effort to minimize the use of character accessors, however, as these can incur significant program overheads.  [[c@]] consumes somewhere in the vicinity of 10 clock cycles, while [[c!]] consumes around 15.</p>

<<Primitives>>=
: c@        dup 1 and if @ 255 and exit then @ 8 rshift 255 and ;
: even!     swap 8 lshift over @ 255 and or swap ! ;
: odd!      swap 255 and over @ $FF00 and or swap ! ;
: c!        dup 1 and if odd! exit then even! ;

@ As you can see above, even addresses correspond to bits 15&hellip;8 of a word, while odd addresses correspond to bits 7&hellip;0.  This maintains consistency with how the video interface refreshes the display, and thus, how it expects bitmap data to be laid out in memory.</p>

<h2>B.3  Displaying Text</h2>

<p>The Kestrel-2 lacks a hardware character matrix display mode; instead, the video circuitry fetches bytes from memory starting at address [[$8000]] and displays them as a raw bitmap.  We cannot simply poke bytes into memory and expect fully-formed characters to appear on the screen.  The Kestrel-2 firmware provides a facility to emulate character matrix displays in software.  This results in a simpler hardware implementation and graphics when you need it, while incurring only modest software costs.</p>

<<Text Display Facility>>=
<<TDF global state>>

@ </p><h3>B.3.1  Character Font</h3>

<p>The 640&times;200 display resolution requires (640&div;16)&times;200=8 000 words of memory.  Using an 8&times;8 pixel font, that allows us to pack 80 columns by 25 rows of text on the screen.  The Kestrel-2 expects a single word of memory to hold two characters (or, put another way, one character consumes eight bits of storage), so (80&div;2)&times;25=1 000 words hold a complete character matrix.  This allows up to 256 characters to be represented by a single character matrix.</p>

<p>Displaying text requires we provide a number of small, 8&times;8 images, each representing some character on the screen.  Each image is known as a <i>glyph</i>.  The <i>font</i> contains the set of glyphs corresponding to each character.  The Kestrel-2 expects the font to exist as a 2 048&times;8 bitmap in memory, for 256 possible characters times 8 pixels per glyph row comes out to 2 048 total pixels.  Thus, the first 128 words (256 bytes) constitutes row 0 pixels for all 256 characters, the next 128 words row 1 pixels, and so on.  Arranging the font data this way allows a developer to use an image editing tool of his or her choice to create a font, then extract the raw bitmap data for direct use with the Kestrel-2.</p>

<p>The Kestrel-2 firmware references the font data via an ancillary Forth source file.
<<Text Display Facility>>=
<<TDF System Font>>

<<TDF System Font>>=
create font
include font.inc
@

<h3>B.3.2  Committing a Character Matrix</h3>

<p>In a perfect world, we would somehow convince the hardware to monitor some region of memory which we call the <i>character matrix</i> for updates.  Whenever we update memory in the matrix, the hardware would somehow recognize this event, and adjust the display accordingly.  As it happens, this is hard to do.  Not impossible, mind you.  There exists two ways to approach the problem&mdash;you could either poll memory at periodic intervals, which is what the video hardware already is designed to do, or you can maintain what's called a <q>write queue</q> to trap writes into the character matrix, where a processor on the other end of the queue discovers these writes and acts accordingly.  As you can imagine, the latter solution is the hardest approach to take of them all, and won't be discussed further here.  The former technique, widely used in such hardware platforms as the VGA-compatible chipsets and the Commodore 64's VIC-II chip, works by accessing memory <i>twice</i>; once to read the character, and once to grab the font data corresponding to that character.  I could have implemented this in the Kestrel-2's video circuitry, but since it roughly doubled the complexity of the hardware involved, I decided to just keep things as simple as possible, and stick with a pure bitmapped display interface.</p>

<p>The problem is, updating the bitmapped display takes eight times the effort than updating a simple character matrix.  Therefore, we want to minimize how often we actually push updates to the bitmapped display.  It's better to compute what we want the finished display to look like first, in the form of the character matrix, <i>then</i> perform a bulk update of the whole screen.  When we talk of <q>committing</q> a character matrix, we're talking about that final act of bulk-updating the bitmapped display.  The term comes from the field of transactions, where updates to a resource occurs when the transaction completes.</p>

<p>I implement a relatively slow algorithm below, but one which is known to work.  It takes the overall form:</p>
<<Text Display Facility>>=
<<TDF address computation logic>>
<<TDF commit glyph logic>>
<<TDF commit row logic>>
<<TDF commit screen-wide logic>>
<<TDF character matrix commit logic>>

@ We commit the display character by character, one glyph at a time, starting in the upper-lefthand corner of the display.  We know we need to update 25 rows of text.</p>

<<TDF character matrix commit logic>>=
: commit    0 x !  0 y !  25r ;

@ We address each character through the [[x]] and [[y]] state variables.  Note that these variables <i>do not</i> refer to any kind of cursor position; they're used only while committing the display, keeping track of which glyph we're painting into the bitmap.  They conform to the invariant that (0&le;<i>x</i>&lt;80)&and;(0&le;<i>y</i>&lt;25) while the screen update continues to proceed.</p>

<<TDF global state>>=
variable x
variable y

@ A screen consists of 25 rows, as established above.  If each execution of [[r]] bumps the [[y]] variable by one, then we can clearly see that upon completion of the operation, [[y]] will be set to 25.  While the update proceeds, we see that 0&le;<i>y</i>&lt;25, thus satisfying the invariant.</p>

<<TDF commit screen-wide logic>>=
: 8r        r r r r  r r r r ;
: 25r       8r 8r 8r r ;

@ Each row consists of 80 characters apiece.  As each row completes, we make sure to reset our (x,y) coordinates to keep track of where the next row begins.  During the update of a single row, 0&le;<i>x</i>&le;80.  However, because [[r]] resets the [[x]] variable back to zero upon finishing each row, and because we know that 0&le;<i>y</i>&lt;25 while the commit progresses, the global invariants hold.</p>

<<TDF commit row logic>>=
: 10c       c c c c c  c c c c c ;
: 80c       10c 10c 10c 10c  10c 10c 10c 10c ;
: r         80c  0 x ! 1 y @ + y ! ;

@ We draw each character by cycling through all eight raster lines of its shape, copying data from the font data to the bitmap along the way.  After we're done copying the glyph, we update our (x,y) state to prepare for the next character to be copied.</p>

<<TDF commit glyph logic>>=
: s         chradr c@ glyph c@ bmadr c!  1 raster @ + raster ! ;
: c         0 raster !  s s s s  s s s s  1 x @ + x ! ;

@ When updating the bitmap, we need to know which character to draw.  We address a character in the character matrix based on the current (valid) values of the [[x]] and [[y]] variables.  The equation to compute an address for any character in the matrix is <i>a</i> = <i>character_matrix_base</i> + <i>x</i> + 80<i>y</i>.</p>

<<TDF address computation logic>>=
: chradr    y @ 80* x @ + TdfChrMtx @ + ;

<<TDF global state>>=
variable TdfChrMtx

@ The TDF user must initialize the [[TdfChrMtx]] variable prior to invoking [[commit]], lest garbage be rendered on the screen.  Further, make sure the 1 000 cells referenced by [[TdfChrMtx]] never overlaps read-triggered I/O space, as the screen update will fire the I/O triggers.</p>

<b>ISSUE: we need a better name for [[TdfChrMtx]].</b>

<p>Next, we need to resolve which row of the glyph's picture to use.  We calculate the glyph's bitmap byte address using the character code (on the data stack) and knowledge of which [[raster]] we're drawing.  Its formula is, <i>a</i> = <i>font_base</i> + <i>c</i> + 256<i>s</i>, where 0&le;<i>c</i>&lt;256 contains the character code, and 0&le;<i>s</i>&lt;8 contains the current raster scanline.

<<TDF address computation logic>>=
: glyph     font + raster @ 256* + ;

<<TDF global state>>=
variable raster

@ Finally, we just place the glyph image data in the destination bitmap.  The correct row of pixels in the target bitmap is computed using a formula similar to that used to determine the character matrix byte address, but adjusted to compensate for the bitmapped nature: <i>a</i> = <i>bitmap_base</i> + <i>x</i> + 80<i>s</i> + 640<i>y</i>, where 0&le;<i>s</i>&lt;8 refers to the specific scanline of the glyph.  Remember, we defined the system font height as eight.</p>

<<TDF address computation logic>>=
: bmadr     y @ 640* raster @ 80* + x @ + $8000 + ;

@ </p><h3>B.3.3  Miscellaneous</h3>

@ You might have noticed a few multiplications going on, expressed as single words instead of separate calls to [[*]].  The J1, not being a terribly sophisticated processor, lacks hardware multiplication support.  This means that we'd need to implement [[*]], a non-trivial task, if we wanted to perform general purpose multiplication.  As it happens, we always multiply by a constant factor, which allows us to create words which computes the desired results using <i>shifts and additions</i> instead.  This also has the benefit of isolating the Text Display Facility from the rest of the system firmware, useful for debugging purposes.</p>

<<Primitives>>=
: 8*        3 lshift ;
: 16*       4 lshift ;
: 80*       4 lshift dup 2 lshift + ;
: 256*      8 lshift ;
: 640*      80* 8* ;

@ </p><h3>B.3.4  Example</h3>

<<TDF Example Code>>=
create myChrmtx
    2048 allot

: c         over over c!  1 + swap 1 + swap ;
: 16cols    c c c c  c c c c  c c c c  c c c c ;
: s         32 over c!  1 + ;
: 16s       s s s s  s s s s  s s s s  s s s s ;
: 64spcs    16s 16s 16s 16s ;
: r         16cols  64spcs ;
: 16rows    r r r r  r r r r  r r r r  r r r r ;
: d         $2E over c!  1 + ;
: 10d       d d d d d  d d d d d ;
: r         10d 10d 10d 10d  10d 10d 10d 10d ;
: 9rows     r r r r  r r r r  r ;
: chrmtx0   0 myChrmtx 16rows 9rows 2drop ;

: halt      $8100 @ invert $8100 !  recurse ;
: main      chrmtx0  myChrmtx TdfChrMtx !  commit  halt ;

